% TXL v6.0 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% TXL Processor v6.0

% Global symbols granted to child modules
grant (
    var cells, var cellCount, var depthTokenAccepted,
    var externalRules, var failRule, var failTokenHandle,
    var ident, var identTable, var inputTokens, var inputTokenKind,
    var inputTokenLineNum,
    var keywordTokens, var nodes, var nodeCount, var notRule, var nKeys,
    var rules, var ruleIndex, var ruleCount, var symbolTable, var symbolTableSize, 
    var tokenHandle, var trees, var objectGrammarTreeNP,
    var fileNames, var nFiles,
    var compoundTokens, var nCompounds, var commentTokens, var nComments,
    var startSpecNodeCount, var startSpecCellCount,

    apply_print_p, boot_parse_p, compile_p,
    debug_p, digitP, enterLocalVar, enterRuleName, 
    enterSymbol, error, findLocalVar, findSymbol, 
    idCharP, identTable, keyP, lastTokenHandle, letterP, load_p, lookupLocalVar, 
    lookupSymbol, lowerP, newCell, newNode, no_comment_p, node_print_p, numberP, 
    parse_print_p, patternError, printLeaves, printLocalVars, printParse, 
    printGrammar, printSkippedToken, rule_print_p, separatorP, sortCompounds, 
    sortKeys, tuning_p, txl_p, txlSourceFileName, upperP, verbose_p)

% Global tables and operations
include "limits.i"
% TXL v6.0 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% TXL Limits

% Maximimum count - limits maxRules, maxKids, and maxLocalVars
const * maxCount := 255

% Maximum token length
const * maxCharsPerToken := 127
% Note -- if you just allow 40 chars per token, then you can't have
% string constants with more then 40 characters in them!

% Maximum compound token or comment bracket length
const * maxCompoundLength := 4  	% e.g. <==>

% Maximum include file depth in a TXL spec
const * maxIncludeDepth := 5

% Maximum defined symbols in the TXL bootstrap grammar
const * maxBootstrapSymbols := 100

% Maximum total defined symbols in a TXL spec
const * maxSymbols := 2000

% Maximum number of keywords in each of bootstrap and TXL spec
const * maxKeys := 400

% Maximum total compound tokens in a TXL spec
const * maxCompoundTokens := 40

% Maximum total comment brackets in a TXL spec
const * maxCommentTokens := 8	% (4 pairs)

% Maximum number of rules in a TXL spec
const * maxRules := 200
assert maxRules < maxCount

% Maximum actual parameters to a rule
const * maxActuals := 10

% Maximum local vars in a rule
const * maxLocalVars := 40
assert maxLocalVars < maxCount

% Maximum conditions, constructors and deconstructors preceding
% or following a pattern in a rule
const * maxParts := 20

% Maximum length of any rule pattern or replacement, in tokens
const * maxPatternTokens := 300

% Maximum different token texts, including identifiers, strings and numbers,
% in entire TXL spec
const * identTableSize := 4096

% Maximum total length of any input,
% including each of: TXL bootstrap grammar, TXL spec, object source
const * maxTokens := 4 * identTableSize

% Maximum number of lines in any single input file,
% including each of: TXL bootstrap grammar, TXL spec, object source
const * maxLines := 4000

% Maximum number of files in any single input,
% including each of: TXL bootstrap grammar, TXL spec, object source
const * maxFiles := 15

% Preferred for storage efficiency
assert maxLines * maxFiles + maxLines < 65536

% Maximum parsing depth in any parse
const * maxParseDepth := 1000

% Maximum parsing depth without an accept before infinite recursion checking
% this used to be 8 - I hope this change increases functionality 
% without slowing things down too much! -- JRC
const * maxBlindParseDepth := 16 

% Maximum number of alternatives in a choice or elements in a sequence
const * maxKids := 127
assert maxKids < maxCount

% Limits on total number of nodes and cells in all trees
%#if MAC then
%    % For Macintosh versions, should be <= 65535 to keep small node sizes
%    % and fit on a reasonable Mac!  (4b*50k + 8b*50k = 600 kb)
%    const * maxCells := 50000
%    const * maxNodes := 50000
%#elsif BIG then
%    % If we ask for it, give us a bit more than usual (8b*500k + 8b*500k = 8 Mb)
%    const * maxCells := 500000
%    const * maxNodes := 500000
%#elsif HUGE then
%    % If we ask for it, give us the works! (8b*1250k + 8b*1250k = 20 Mb)
%    const * maxCells := 1250000
%    const * maxNodes := 1250000
%#else
    % Otherwise, give us a nice slim default (8b*125k + 8b*125k = 2 Mb)
    const * maxCells := 125000
    const * maxNodes := 125000
%#end if
include "error.i"
% TXL v5.3 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% Error message handling

const * FATAL := 0
const * WARNING := 1

procedure error (message : string, level : int)
    put : 0, "TXL ERROR : ", message
    if level = FATAL then
	quit 
    end if
end error
include "tokens.i"
% TXL v6.0 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% TXL Input Tokens

% Tokens are represented by their Identifier/Text table indices for efficiency
const * NOT_FOUND := identTableSize + 1
const * NO_ROOM := identTableSize + 2
type * tokenT : packed 0 .. identTableSize + 2

% Kinds of nodes in TXL trees - defined here so that we can encode
% literal kinds in the token table
type * kindT :
    packed enum (empty, order, choose, literal, stringlit, charlit, token,
	id, upperlowerid, upperid, lowerupperid, lowerid,
	number, floatnumber, decimalnumber, integernumber,
	key, firstTime, subsequentUse, expression, ruleCall, undefined)

% The input token table - assists in full backup parsing
type * inputTokenHT : 0 .. maxTokens
var inputTokens : array 1 .. maxTokens of tokenT 
var inputTokenKind : array 1 .. maxTokens of kindT 
type * lineNumberT : packed 0 .. maxFiles * maxLines + maxLines
var inputTokenLineNum : array 1 .. maxTokens of lineNumberT 

% The current, last and furthest accepted token in the table
var tokenHandle, lastTokenHandle, failTokenHandle : inputTokenHT 

% Token values are strings
type * tokenValueT : string (maxCharsPerToken)

% Markers used to keep track of how far to back up the input when doing
% general backtracking.
type * tokenDepthT : packed 0 .. maxTokens  % (sic)
var depthTokenAccepted : array 0 .. maxTokens of tokenDepthT % GLOBAL
depthTokenAccepted (0) := 0

% File name table
var nFiles := 0
var fileNames : array 1 .. maxFiles of string

% compound tokens
type * compoundT : string (maxCompoundLength)
var nCompounds := 0
var compoundTokens : array 1..maxCompoundTokens of compoundT

% comment bracket tokens - pairs
var commentTokens : array 1..maxCommentTokens of compoundT
var nComments := 2		% comment brackets come in pairs
commentTokens (1) := "%"	% default Turing comments
commentTokens (2) := ""		% end at eol

% Holds both TXL and object language keywordTokens
var nKeys := 0
var keywordTokens : array 1 .. maxKeys of tokenT

% Properties of tokens and text
const F := false
const T := true

const letterP : array chr (0) .. chr (255) of boolean := init (T,F)
%%    /*nul*/ F, /*soh*/ F, /*stx*/ F, /*etx*/ F, /*eot*/ F, /*enq*/ F, /*ack*/ F, /*bel*/ F,
%%    /*bs */ F, /*ht */ F, /*nl */ F, /*vt */ F, /*np */ F, /*cr */ F, /*so */ F, /*si */ F,
%%    /*dle*/ F, /*dc1*/ F, /*dc2*/ F, /*dc3*/ F, /*dc4*/ F, /*nak*/ F, /*syn*/ F, /*etb*/ F,
%%    /*can*/ F, /*em */ F, /*sub*/ F, /*esc*/ F, /*fs */ F, /*gs */ F, /*rs */ F, /*us */ F,
%%    /*sp */ F, /* ! */ F, /* " */ F, /* # */ F, /* $ */ F, /* % */ F, /* & */ F, /* ' */ F,
%%    /* ( */ F, /* ) */ F, /* * */ F, /* + */ F, /* , */ F, /* - */ F, /* . */ F, /* / */ F,
%%    /* 0 */ F, /* 1 */ F, /* 2 */ F, /* 3 */ F, /* 4 */ F, /* 5 */ F, /* 6 */ F, /* 7 */ F,
%%    /* 8 */ F, /* 9 */ F, /* : */ F, /* ; */ F, /* < */ F, /* = */ F, /* > */ F, /* ? */ F,
%%    /* @ */ F, /* A */ T, /* B */ T, /* C */ T, /* D */ T, /* E */ T, /* F */ T, /* G */ T,
%%    /* H */ T, /* I */ T, /* J */ T, /* K */ T, /* L */ T, /* M */ T, /* N */ T, /* O */ T,
%%    /* P */ T, /* Q */ T, /* R */ T, /* S */ T, /* T */ T, /* U */ T, /* V */ T, /* W */ T,
%%    /* X */ T, /* Y */ T, /* Z */ T, /* [ */ F, /* \ */ F, /* ] */ F, /* ^ */ F, /* _ */ F,
%%    /* ` */ F, /* a */ T, /* b */ T, /* c */ T, /* d */ T, /* e */ T, /* f */ T, /* g */ T,
%%    /* h */ T, /* i */ T, /* j */ T, /* k */ T, /* l */ T, /* m */ T, /* n */ T, /* o */ T,
%%    /* p */ T, /* q */ T, /* r */ T, /* s */ T, /* t */ T, /* u */ T, /* v */ T, /* w */ T,
%%    /* x */ T, /* y */ T, /* z */ T, /* { */ F, /* | */ F, /* } */ F, /* ~ */ F, /*del*/ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F)

const upperP : array chr (0) .. chr (255) of boolean := init (T,F)
%%     /*nul*/ F, /*soh*/ F, /*stx*/ F, /*etx*/ F, /*eot*/ F, /*enq*/ F, /*ack*/ F, /*bel*/ F,
%%     /*bs */ F, /*ht */ F, /*nl */ F, /*vt */ F, /*np */ F, /*cr */ F, /*so */ F, /*si */ F,
%%     /*dle*/ F, /*dc1*/ F, /*dc2*/ F, /*dc3*/ F, /*dc4*/ F, /*nak*/ F, /*syn*/ F, /*etb*/ F,
%%     /*can*/ F, /*em */ F, /*sub*/ F, /*esc*/ F, /*fs */ F, /*gs */ F, /*rs */ F, /*us */ F,
%%     /*sp */ F, /* ! */ F, /* " */ F, /* # */ F, /* $ */ F, /* % */ F, /* & */ F, /* ' */ F,
%%     /* ( */ F, /* ) */ F, /* * */ F, /* + */ F, /* , */ F, /* - */ F, /* . */ F, /* / */ F,
%%     /* 0 */ F, /* 1 */ F, /* 2 */ F, /* 3 */ F, /* 4 */ F, /* 5 */ F, /* 6 */ F, /* 7 */ F,
%%     /* 8 */ F, /* 9 */ F, /* : */ F, /* ; */ F, /* < */ F, /* = */ F, /* > */ F, /* ? */ F,
%%     /* @ */ F, /* A */ T, /* B */ T, /* C */ T, /* D */ T, /* E */ T, /* F */ T, /* G */ T,
%%     /* H */ T, /* I */ T, /* J */ T, /* K */ T, /* L */ T, /* M */ T, /* N */ T, /* O */ T,
%%     /* P */ T, /* Q */ T, /* R */ T, /* S */ T, /* T */ T, /* U */ T, /* V */ T, /* W */ T,
%%     /* X */ T, /* Y */ T, /* Z */ T, /* [ */ F, /* \ */ F, /* ] */ F, /* ^ */ F, /* _ */ F,
%%     /* ` */ F, /* a */ F, /* b */ F, /* c */ F, /* d */ F, /* e */ F, /* f */ F, /* g */ F,
%%     /* h */ F, /* i */ F, /* j */ F, /* k */ F, /* l */ F, /* m */ F, /* n */ F, /* o */ F,
%%     /* p */ F, /* q */ F, /* r */ F, /* s */ F, /* t */ F, /* u */ F, /* v */ F, /* w */ F,
%%     /* x */ F, /* y */ F, /* z */ F, /* { */ F, /* | */ F, /* } */ F, /* ~ */ F, /*del*/ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F)
%% 
const lowerP : array chr (0) .. chr (255) of boolean := init (T,F)
%%     /*nul*/ F, /*soh*/ F, /*stx*/ F, /*etx*/ F, /*eot*/ F, /*enq*/ F, /*ack*/ F, /*bel*/ F,
%%     /*bs */ F, /*ht */ F, /*nl */ F, /*vt */ F, /*np */ F, /*cr */ F, /*so */ F, /*si */ F,
%%     /*dle*/ F, /*dc1*/ F, /*dc2*/ F, /*dc3*/ F, /*dc4*/ F, /*nak*/ F, /*syn*/ F, /*etb*/ F,
%%     /*can*/ F, /*em */ F, /*sub*/ F, /*esc*/ F, /*fs */ F, /*gs */ F, /*rs */ F, /*us */ F,
%%     /*sp */ F, /* ! */ F, /* " */ F, /* # */ F, /* $ */ F, /* % */ F, /* & */ F, /* ' */ F,
%%     /* ( */ F, /* ) */ F, /* * */ F, /* + */ F, /* , */ F, /* - */ F, /* . */ F, /* / */ F,
%%     /* 0 */ F, /* 1 */ F, /* 2 */ F, /* 3 */ F, /* 4 */ F, /* 5 */ F, /* 6 */ F, /* 7 */ F,
%%     /* 8 */ F, /* 9 */ F, /* : */ F, /* ; */ F, /* < */ F, /* = */ F, /* > */ F, /* ? */ F,
%%     /* @ */ F, /* A */ F, /* B */ F, /* C */ F, /* D */ F, /* E */ F, /* F */ F, /* G */ F,
%%     /* H */ F, /* I */ F, /* J */ F, /* K */ F, /* L */ F, /* M */ F, /* N */ F, /* O */ F,
%%     /* P */ F, /* Q */ F, /* R */ F, /* S */ F, /* T */ F, /* U */ F, /* V */ F, /* W */ F,
%%     /* X */ F, /* Y */ F, /* Z */ F, /* [ */ F, /* \ */ F, /* ] */ F, /* ^ */ F, /* _ */ F,
%%     /* ` */ F, /* a */ T, /* b */ T, /* c */ T, /* d */ T, /* e */ T, /* f */ T, /* g */ T,
%%     /* h */ T, /* i */ T, /* j */ T, /* k */ T, /* l */ T, /* m */ T, /* n */ T, /* o */ T,
%%     /* p */ T, /* q */ T, /* r */ T, /* s */ T, /* t */ T, /* u */ T, /* v */ T, /* w */ T,
%%     /* x */ T, /* y */ T, /* z */ T, /* { */ F, /* | */ F, /* } */ F, /* ~ */ F, /*del*/ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F)
%% 
const idCharP : array chr (0) .. chr (255) of boolean := init (T,F)
%%     /*nul*/ F, /*soh*/ F, /*stx*/ F, /*etx*/ F, /*eot*/ F, /*enq*/ F, /*ack*/ F, /*bel*/ F,
%%     /*bs */ F, /*ht */ F, /*nl */ F, /*vt */ F, /*np */ F, /*cr */ F, /*so */ F, /*si */ F,
%%     /*dle*/ F, /*dc1*/ F, /*dc2*/ F, /*dc3*/ F, /*dc4*/ F, /*nak*/ F, /*syn*/ F, /*etb*/ F,
%%     /*can*/ F, /*em */ F, /*sub*/ F, /*esc*/ F, /*fs */ F, /*gs */ F, /*rs */ F, /*us */ F,
%%     /*sp */ F, /* ! */ F, /* " */ F, /* # */ F, /* $ */ F, /* % */ F, /* & */ F, /* ' */ F,
%%     /* ( */ F, /* ) */ F, /* * */ F, /* + */ F, /* , */ F, /* - */ F, /* . */ F, /* / */ F,
%%     /* 0 */ T, /* 1 */ T, /* 2 */ T, /* 3 */ T, /* 4 */ T, /* 5 */ T, /* 6 */ T, /* 7 */ T,
%%     /* 8 */ T, /* 9 */ T, /* : */ F, /* ; */ F, /* < */ F, /* = */ F, /* > */ F, /* ? */ F,
%%     /* @ */ F, /* A */ T, /* B */ T, /* C */ T, /* D */ T, /* E */ T, /* F */ T, /* G */ T,
%%     /* H */ T, /* I */ T, /* J */ T, /* K */ T, /* L */ T, /* M */ T, /* N */ T, /* O */ T,
%%     /* P */ T, /* Q */ T, /* R */ T, /* S */ T, /* T */ T, /* U */ T, /* V */ T, /* W */ T,
%%     /* X */ T, /* Y */ T, /* Z */ T, /* [ */ F, /* \ */ F, /* ] */ F, /* ^ */ F, /* _ */ T,
%%     /* ` */ F, /* a */ T, /* b */ T, /* c */ T, /* d */ T, /* e */ T, /* f */ T, /* g */ T,
%%     /* h */ T, /* i */ T, /* j */ T, /* k */ T, /* l */ T, /* m */ T, /* n */ T, /* o */ T,
%%     /* p */ T, /* q */ T, /* r */ T, /* s */ T, /* t */ T, /* u */ T, /* v */ T, /* w */ T,
%%     /* x */ T, /* y */ T, /* z */ T, /* { */ F, /* | */ F, /* } */ F, /* ~ */ F, /*del*/ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F)
%% 
const separatorP : array chr (0) .. chr (255) of boolean := init (T,F)
%%     /*nul*/ F, /*soh*/ F, /*stx*/ F, /*etx*/ F, /*eot*/ F, /*enq*/ F, /*ack*/ F, /*bel*/ F,
%%     /*bs */ F, /*ht */ T, /*nl */ T, /*vt */ F, /*np */ T, /*cr */ T, /*so */ F, /*si */ F,
%%     /*dle*/ F, /*dc1*/ F, /*dc2*/ F, /*dc3*/ F, /*dc4*/ F, /*nak*/ F, /*syn*/ F, /*etb*/ F,
%%     /*can*/ F, /*em */ F, /*sub*/ F, /*esc*/ F, /*fs */ F, /*gs */ F, /*rs */ F, /*us */ F,
%%     /*sp */ T, /* ! */ F, /* " */ F, /* # */ F, /* $ */ F, /* % */ F, /* & */ F, /* ' */ F,
%%     /* ( */ F, /* ) */ F, /* * */ F, /* + */ F, /* , */ F, /* - */ F, /* . */ F, /* / */ F,
%%     /* 0 */ F, /* 1 */ F, /* 2 */ F, /* 3 */ F, /* 4 */ F, /* 5 */ F, /* 6 */ F, /* 7 */ F,
%%     /* 8 */ F, /* 9 */ F, /* : */ F, /* ; */ F, /* < */ F, /* = */ F, /* > */ F, /* ? */ F,
%%     /* @ */ F, /* A */ F, /* B */ F, /* C */ F, /* D */ F, /* E */ F, /* F */ F, /* G */ F,
%%     /* H */ F, /* I */ F, /* J */ F, /* K */ F, /* L */ F, /* M */ F, /* N */ F, /* O */ F,
%%     /* P */ F, /* Q */ F, /* R */ F, /* S */ F, /* T */ F, /* U */ F, /* V */ F, /* W */ F,
%%     /* X */ F, /* Y */ F, /* Z */ F, /* [ */ F, /* \ */ F, /* ] */ F, /* ^ */ F, /* _ */ F,
%%     /* ` */ F, /* a */ F, /* b */ F, /* c */ F, /* d */ F, /* e */ F, /* f */ F, /* g */ F,
%%     /* h */ F, /* i */ F, /* j */ F, /* k */ F, /* l */ F, /* m */ F, /* n */ F, /* o */ F,
%%     /* p */ F, /* q */ F, /* r */ F, /* s */ F, /* t */ F, /* u */ F, /* v */ F, /* w */ F,
%%     /* x */ F, /* y */ F, /* z */ F, /* { */ F, /* | */ F, /* } */ F, /* ~ */ F, /*del*/ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F)
%% 
const digitP : array chr (0) .. chr (255) of boolean := init (T,F)
%%     /*nul*/ F, /*soh*/ F, /*stx*/ F, /*etx*/ F, /*eot*/ F, /*enq*/ F, /*ack*/ F, /*bel*/ F,
%%     /*bs */ F, /*ht */ F, /*nl */ F, /*vt */ F, /*np */ F, /*cr */ F, /*so */ F, /*si */ F,
%%     /*dle*/ F, /*dc1*/ F, /*dc2*/ F, /*dc3*/ F, /*dc4*/ F, /*nak*/ F, /*syn*/ F, /*etb*/ F,
%%     /*can*/ F, /*em */ F, /*sub*/ F, /*esc*/ F, /*fs */ F, /*gs */ F, /*rs */ F, /*us */ F,
%%     /*sp */ F, /* ! */ F, /* " */ F, /* # */ F, /* $ */ F, /* % */ F, /* & */ F, /* ' */ F,
%%     /* ( */ F, /* ) */ F, /* * */ F, /* + */ F, /* , */ F, /* - */ F, /* . */ F, /* / */ F,
%%     /* 0 */ T, /* 1 */ T, /* 2 */ T, /* 3 */ T, /* 4 */ T, /* 5 */ T, /* 6 */ T, /* 7 */ T,
%%     /* 8 */ T, /* 9 */ T, /* : */ F, /* ; */ F, /* < */ F, /* = */ F, /* > */ F, /* ? */ F,
%%     /* @ */ F, /* A */ F, /* B */ F, /* C */ F, /* D */ F, /* E */ F, /* F */ F, /* G */ F,
%%     /* H */ F, /* I */ F, /* J */ F, /* K */ F, /* L */ F, /* M */ F, /* N */ F, /* O */ F,
%%     /* P */ F, /* Q */ F, /* R */ F, /* S */ F, /* T */ F, /* U */ F, /* V */ F, /* W */ F,
%%     /* X */ F, /* Y */ F, /* Z */ F, /* [ */ F, /* \ */ F, /* ] */ F, /* ^ */ F, /* _ */ F,
%%     /* ` */ F, /* a */ F, /* b */ F, /* c */ F, /* d */ F, /* e */ F, /* f */ F, /* g */ F,
%%     /* h */ F, /* i */ F, /* j */ F, /* k */ F, /* l */ F, /* m */ F, /* n */ F, /* o */ F,
%%     /* p */ F, /* q */ F, /* r */ F, /* s */ F, /* t */ F, /* u */ F, /* v */ F, /* w */ F,
%%     /* x */ F, /* y */ F, /* z */ F, /* { */ F, /* | */ F, /* } */ F, /* ~ */ F, /*del*/ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%     /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F)


procedure sortKeys
    bind var register kwt to keywordTokens
    for decreasing k : nKeys .. 2
	var swap := false
	for j : 2 .. k
	    if kwt (j - 1) > kwt (j) then
		const temp := kwt (j - 1)
		kwt (j - 1) := kwt (j)
		kwt (j) := temp
		swap := true
	    end if
	end for
	exit when not swap
    end for
end sortKeys


procedure sortCompounds
    % sort into reverse order to catch longest match!
    bind var register c to compoundTokens
    for decreasing k : nCompounds .. 2
	var swap := false
	for j : 2 .. k
	    if c (j - 1) < c (j) then
		const temp := c (j - 1)
		c (j - 1) := c (j)
		c (j) := temp
		swap := true
	    end if
	end for
	exit when not swap
    end for
end sortCompounds


function keyP (token : tokenT) : boolean
    var register lo : nat := 1
    var register hi : nat := nKeys 
    loop
	exit when lo > hi

	const mid : nat := (lo + hi) div 2
	const register kwtmid : tokenT := keywordTokens (mid)

	if token < kwtmid then
	    hi := mid - 1
	elsif token > kwtmid then
	    lo := mid + 1
	else
	    result true
	end if
    end loop
    result false
end keyP


function numberP (tokenText : string) : boolean
    for c : 1 .. length (tokenText)
	const tc : char := tokenText (c)
        if not digitP (tc) then
            result false
        end if
    end for
    result true
end numberP
include "ident_table.i"
% TXL v5.3 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% Identifier/Text Table

% Can't export a variable, so this one is outside the module for efficiency
%#if MAC then
%    % get around MPW C limitations by using a dynamically allocated array
%    var dynamicTableSize := identTableSize - 1
%    var identTable : array 0 .. dynamicTableSize of tokenValueT
%#else
    var identTable : array 0 .. identTableSize - 1 of tokenValueT
%#end if

%child "ident_ops.ch"
% TXL v5.3 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% Identifier/Text Table Operations

%parent "txl.t"

stub module ident
    import (var identTable, error)
    export (install, lookup)
    function lookup (ident : tokenValueT) : tokenT
    procedure install (ident : tokenValueT, var resultIndex : tokenT)
end ident

body module ident

    const pervasive JUMP := 83

    % Initialize the table
    identTable (0) := " "
    identTable (128) := " "

    for i : 1 ..127
        identTable (i) := chr (i)
	identTable (i + 128) := chr (i)
    end for

    for i : 256 .. identTableSize - 1
        identTable (i) := ""
    end for


    body function lookup % (ident : tokenValueT) : tokenT

	const lengthid := length (ident)

        if lengthid = 1 then
            result ord (ident (1))
        else
	    assert lengthid >= 2
	    const firstchar := ord (ident (1))
	    const lastchar := ord (ident (lengthid))

	    var register identIndex : nat := 
		firstchar * 128 + lastchar * 16 + lengthid
	    identIndex and= identTableSize - 1
            const startIndex : nat := identIndex

            loop
		bind register idt to identTable (identIndex)

                exit when idt = ident

		if idt = "" then
		    result NOT_FOUND
		end if

                identIndex += JUMP
                identIndex and= identTableSize - 1

                if identIndex = startIndex then
                    result NO_ROOM
                end if
            end loop

            result identIndex
        end if
    end lookup


    body procedure install %(ident : tokenValueT, var resultIndex : tokenT)

	const lengthid := length (ident)

        if lengthid = 1 then
            resultIndex :=  ord (ident (1))
        else
	    assert lengthid >= 2
	    const firstchar := ord (ident (1))
	    const lastchar := ord (ident (lengthid))

	    var register identIndex : nat := 
		firstchar * 128 + lastchar * 16 + lengthid
	    identIndex and= identTableSize - 1
            const startIndex : nat := identIndex

            loop
		bind var register idt to identTable (identIndex)

		if idt = "" then
		    idt := ident
		    exit
		end if

                exit when idt = ident

                identIndex += JUMP
                identIndex and= identTableSize - 1

                if identIndex = startIndex then
		    error ("Source file too big (token text table overflow)", FATAL)
                end if
            end loop

            resultIndex := identIndex
        end if

    end install

end ident
include "trees.i"
% TXL v5.3 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% Definitions for TXL Labelled Tree structures

% Trees are structured as nodes and cells, in the traditional Lisp 
% cons cell fashion.  

% I.E., the tree:	  Is represented as:
%
%	      X			X--+-------------+
%	     / \		   |             |
%	    Y   Z		   Y--+--+--+	 Z
%          /|\			      |  |  |
%         / | \			      A  B  C--+--+
%	 A  B  C			       |  |
%             / \			       D  E
%            D   E

% where each label is in a node, and each node has
% a linked list of cells (+'s) pointing to the children of the node.

% Kinds of nodes in TXL trees - defined in tokens.i
% type * kindT :
%    packed enum (order, choose, literal, stringlit, charlit, token,
%	id, upperlowerid, upperid, lowerupperid, lowerid,
%	number, floatnumber, decimalnumber, integernumber,
%	key, firstTime, subsequentUse, expression, ruleCall, undefined)

% WARNING: Due to T+ bugs, these MUST be subranges!
type * cellPT : packed 0 .. maxCells
type * nodePT : packed 0 .. maxNodes

const * nilNode := 0
const * nilCell := 0

type * consCellT :
    record
	firstNP : nodePT
	restCP : cellPT
    end record

const cellSizeCheck := 
    %#if MAC then
%	size (consCellT) = 4
%    #else
	size (consCellT) = 8
%    #end if

if not cellSizeCheck then
    error ("TXL Fatal error (cell size assertion failed)", FATAL)
end if

type * countT : packed 0 .. maxCount

type * patternAndParseNodeT :
    record
	kidsCP : cellPT % list of children
	name : tokenT % name or literal value
	kind : kindT
	count : countT % how many children
    end record

const nodeSizeCheck := 
    %#if MAC then
%	size (patternAndParseNodeT) = 6
%    #else
	size (patternAndParseNodeT) = 8
%    #end if

if not nodeSizeCheck then
    error ("TXL Fatal error (node size assertion failed)", FATAL)
end if

%#if MAC then
%    % get around MPW C limitations by using a dynamically allocated array
%    var dynamicMaxCells := maxCells
%    var cells : array 1..dynamicMaxCells of consCellT
%    var dynamicMaxNodes := maxNodes
%    var nodes : array 1..dynamicMaxNodes of patternAndParseNodeT
%#else
    var cells : array 1..maxCells of consCellT
    var nodes : array 1..maxNodes of patternAndParseNodeT
%#end if

var nodeCount := 0
var cellCount := 0

%#if MAC then
%    include "%ToolBox:CursorCtl.i"
%#end if

const * outOfNodes := 951
const * outOfCells := 952

procedure newNode (var n : nodePT)
    if nodeCount = maxNodes then
	error ("(Fatal) Out of node space - " +
	    intstr (nodeCount, 1) + " nodes have been allocated.", WARNING)
	quit : outOfNodes
    end if
    nodeCount += 1
    n := nodeCount
%    #if MAC then
%	if nodeCount mod 8 = 0 then
%	    SpinCursor (1)
%	end if
%    #end if
end newNode

procedure newCell (var c : cellPT)
    if cellCount = maxCells then
	error ("(Fatal) Out of cell space - " +
	    intstr (cellCount, 1) + " cells have been allocated.", WARNING)
	quit : outOfCells
    end if
    cellCount += 1
    c := cellCount
end newCell

% Tree operations library
%child "tree_ops.ch"
% TXL v6.0 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% TXL Tree Handling Operations

%parent "txl.t"

% Module to encapsulate the library of tree handling operations
stub module trees
    import (var nodes, newNode, var cells, newCell, 
	var nodeCount, var cellCount, identTable, var ident, 
	error)

    export (makeOneKid, makeTwoKids, makeThreeKids, 
	contiguousKids, kidNP, kid1NP, kid2NP,
	kid3NP, kid4NP, plural_emptyP, plural_firstNP, plural_restNP,
	patternOrReplacement_litsAndVarsAndExpsNP, 
	external_nameT, external_formalsNP, rule_targetT,
	construct_varNameT, construct_targetT, construct_replacementNP,
	deconstruct_varNameT, deconstruct_patternNP, rule_nameT, 
	rule_prePatternNP, rule_postPatternNP, rule_patternNP, 
	rule_optSkippingNP, optSkipping_nameT, 
	rule_replaceOrMatchT, rule_optByReplacementNP, optByReplacement_replacementNP, 
	rule_formalsNP, formal_nameT, formal_typeT, 
	isQuotedLiteral, literal_tokenT, literal_kindT, ruleCall_nameT, 
	ruleCall_literalsNP, bracketedDescription_idT,
	bracketedDescription_listRepeatOrOptTargetNP,
	firstTime_nameT, firstTime_typeT,
	expression_baseT, expression_ruleCallsNP,
	program_statementsNP, keys_literalsNP, define_nameT, 
	define_literalsAndBracketedIdsNP, define_barOrdersNP,
	statement_keyDefRuleNP, condition_expressionNP,
	isListOrRepeat, lengthListOrRepeat, listOrRepeatFirstNP, listOrRepeatRestNP,
	isListOrRepeatType, listOrRepeatBaseType, sameTrees, literalOrBracketedIdP, 
	bracketedDescriptionP, quotedLiteralP, literalP, listP, list1P, repeatP, repeat1P, optP, 
	nodeIsTypeP, literalTypeName, copyTree)

    procedure makeOneKid (parentNP : nodePT, babyNP : nodePT)
    procedure makeTwoKids (parentNP : nodePT, buddyNP : nodePT, sisNP : nodePT)
    procedure makeThreeKids (parentNP : nodePT, buddyNP : nodePT,
	sisNP : nodePT, babyNP : nodePT)
    function contiguousKids (parentNP : nodePT) : boolean
    function kidNP (which : nat, parentNP : nodePT) : nodePT
    function kid1NP (nodeP : nodePT) : nodePT
    function kid2NP (nodeP : nodePT) : nodePT
    function kid3NP (nodeP : nodePT) : nodePT
    function kid4NP (nodeP : nodePT) : nodePT
    function plural_emptyP (pluralNP : nodePT) : boolean
    function plural_firstNP (pluralNP : nodePT) : nodePT
    function plural_restNP (pluralNP : nodePT) : nodePT
     function patternOrReplacement_litsAndVarsAndExpsNP 
	    (patternOrReplacementNP : nodePT) : nodePT
    function external_nameT (externalNP : nodePT) : tokenT
    function external_formalsNP (externalNP : nodePT) : nodePT
    function rule_targetT (ruleNP : nodePT) : tokenT
    function construct_varNameT (constructNP : nodePT) : tokenT
    function construct_targetT(constructNP : nodePT) : tokenT
    function construct_replacementNP(constructNP : nodePT) : nodePT
    function deconstruct_varNameT(constructNP : nodePT) : tokenT
    function deconstruct_patternNP(constructNP : nodePT) : nodePT
    function rule_nameT (ruleNP : nodePT) : tokenT
    function rule_prePatternNP (ruleNP : nodePT) : nodePT
    function rule_postPatternNP (ruleNP : nodePT) : nodePT
    function rule_patternNP (ruleNP : nodePT) : nodePT
    function rule_replaceOrMatchT (ruleNP : nodePT) : tokenT
    function rule_optByReplacementNP (ruleNP : nodePT) : nodePT
    function optByReplacement_replacementNP (optByReplacementNP : nodePT) : nodePT
    function rule_optSkippingNP (ruleNP : nodePT) : nodePT
    function optSkipping_nameT (optSkippingNP : nodePT) : tokenT
    function rule_formalsNP (ruleNP : nodePT) : nodePT
    function formal_nameT (argumentNP : nodePT) : tokenT
    function formal_typeT (argumentNP : nodePT) : tokenT
    function isQuotedLiteral (literalNP : nodePT) : boolean
    function literal_tokenT (literalNP : nodePT) : tokenT
    function literal_kindT (literalNP : nodePT) : kindT
    function ruleCall_nameT (ruleCallNP : nodePT) : tokenT
    function ruleCall_literalsNP (ruleCallNP : nodePT) : nodePT
    function bracketedDescription_idT (bracketedDescriptionNP : nodePT) : tokenT
    function bracketedDescription_listRepeatOrOptTargetNP  (bracketedDescriptionNP : nodePT) : nodePT
    function firstTime_nameT (firstTimeNP : nodePT) : tokenT
    function firstTime_typeT (firstTimeNP : nodePT) : tokenT
    function expression_baseT (expressionNP : nodePT) : tokenT
    function expression_ruleCallsNP (expressionNP : nodePT) : nodePT
    function program_statementsNP (programNP : nodePT) : nodePT
    function keys_literalsNP (keyListNP : nodePT) : nodePT
    function define_nameT (defineNP : nodePT) : tokenT
    function define_literalsAndBracketedIdsNP (defineNP : nodePT) : nodePT
    function define_barOrdersNP (defineNP : nodePT) : nodePT
    function statement_keyDefRuleNP (statementNP : nodePT) : nodePT
    function condition_expressionNP (conditionNP : nodePT) : nodePT
    function isListOrRepeat (listOrRepeatNP : nodePT) : boolean
    function lengthListOrRepeat (listOrRepeatNP : nodePT) : int
    function listOrRepeatFirstNP (listOrRepeatNP : nodePT) : nodePT
    function listOrRepeatRestNP (listOrRepeatNP : nodePT) : nodePT
    function isListOrRepeatType (listOrRepeatType : tokenT) : boolean
    function listOrRepeatBaseType (listOrRepeatType: tokenT) : tokenT
    function sameTrees (tree1NP, tree2NP : nodePT) : boolean
    function literalOrBracketedIdP (nodeP : nodePT) : boolean
    function bracketedDescriptionP (nodeP : nodePT) : boolean
    function quotedLiteralP (nodeP : nodePT) : boolean
    function literalP (nodeP : nodePT) : boolean
    function listP (bracketedDescriptionNP : nodePT) : boolean
    function repeatP (bracketedDescriptionNP : nodePT) : boolean
    function list1P (bracketedDescriptionNP : nodePT) : boolean
    function repeat1P (bracketedDescriptionNP : nodePT) : boolean
    function optP (bracketedDescriptionNP : nodePT) : boolean
    function nodeIsTypeP (nodeP : nodePT, typeT : tokenT) : boolean
    function literalTypeName (kind : kindT) : tokenT
    procedure copyTree (originalNP : nodePT, var copyNP : nodePT)
end trees


body module trees

    body function kidNP % (which : nat, parentNP : nodePT) : nodePT
	pre which >= 1
	var register c := nodes (parentNP).kidsCP
	for kid : 2 .. which 
	    c := cells (c).restCP
	end for
	result cells (c).firstNP
    end kidNP

    body function kid1NP % (nodeP : nodePT) : nodePT
	result cells (nodes (nodeP).kidsCP).firstNP
    end kid1NP

    body function kid2NP % (nodeP : nodePT) : nodePT
%    	#if MAC then
%		const restKidsCP := cells (nodes (nodeP).kidsCP).restCP
%	    	result cells (restKidsCP).firstNP
%	#else
		result cells (cells (nodes (nodeP).kidsCP).restCP).firstNP
%	#end if
    end kid2NP

    body function kid3NP % (nodeP : nodePT) : nodePT
%	#if MAC then
%	    	result kidNP (3, nodeP)
%	#else
		result cells (cells (cells (nodes (nodeP).kidsCP).restCP).restCP).firstNP
%	#end if
    end kid3NP

    body function kid4NP % (nodeP : nodePT) : nodePT
%	#if MAC then
%	    	result kidNP (4, nodeP)
%	#else
		result cells (cells (cells (cells (nodes (nodeP).kidsCP).restCP).restCP).restCP).firstNP
%	#end if
    end kid4NP

    body procedure makeOneKid % (parentNP : nodePT, babyNP : nodePT)
	newCell (nodes (parentNP).kidsCP)
	cells (nodes (parentNP).kidsCP).firstNP := babyNP
	cells (nodes (parentNP).kidsCP).restCP := nilCell
	nodes (parentNP).count := 1
    end makeOneKid

    body procedure makeTwoKids % (parentNP : nodePT, buddyNP : nodePT, sisNP : nodePT)
	newCell (nodes (parentNP).kidsCP)
	cells (nodes (parentNP).kidsCP).firstNP := buddyNP
	newCell (cells (nodes (parentNP).kidsCP).restCP)
	const tempCP := cells (nodes (parentNP).kidsCP).restCP
	cells (tempCP).firstNP := sisNP
	cells (tempCP).restCP := nilCell
	nodes (parentNP).count := 2
    end makeTwoKids

    body procedure makeThreeKids % (parentNP : nodePT, buddyNP : nodePT,
	    % sisNP : nodePT, babyNP : nodePT)
	var tempCP : cellPT
	newCell (nodes (parentNP).kidsCP)
	tempCP := nodes (parentNP).kidsCP
	cells (tempCP).firstNP := buddyNP
	newCell (cells (tempCP).restCP)
	tempCP := cells (tempCP).restCP
	cells (tempCP).firstNP := sisNP
	newCell (cells (tempCP).restCP)
	tempCP := cells (tempCP).restCP
	cells (tempCP).firstNP := babyNP
	cells (tempCP).restCP := nilCell
	nodes (parentNP).count := 3
    end makeThreeKids

    body function contiguousKids % (parentNP : nodePT) : boolean
	var kidCP, prevKidCP := nodes (parentNP).kidsCP
	for k : 1 .. nodes (parentNP).count
	    kidCP := cells (kidCP).restCP
	    exit when kidCP = nilCell
	    if kidCP not= prevKidCP + 1 then
		result false
	    end if
	    prevKidCP := kidCP
	end for
	result true
    end contiguousKids

    body function plural_emptyP % (pluralNP : nodePT) : boolean
	result nodes (kid1NP (pluralNP)).kind = kindT.empty
    end plural_emptyP

    body function plural_firstNP % (pluralNP : nodePT) : nodePT
	result kid1NP (kid1NP (pluralNP))
    end plural_firstNP

    body function plural_restNP % (pluralNP : nodePT) : nodePT
	result kid2NP (kid1NP (pluralNP))
    end plural_restNP

    body function patternOrReplacement_litsAndVarsAndExpsNP 
	    % (patternOrReplacementNP : nodePT) : nodePT
	pre identTable (nodes (patternOrReplacementNP).name) = "TXL_pattern_" or
	     identTable (nodes (patternOrReplacementNP).name) = "TXL_replacement_"
	result kid1NP (patternOrReplacementNP)
    end patternOrReplacement_litsAndVarsAndExpsNP

    body function external_nameT % (externalNP : nodePT) : tokenT
	pre identTable (nodes(externalNP).name) = "TXL_externalStatement_"
	result nodes(kid3NP(externalNP)).name
    end external_nameT

    body function external_formalsNP % (externalNP : nodePT) : nodePT
	pre identTable (nodes (externalNP).name) = "TXL_externalStatement_" and
	    identTable (nodes (kid4NP(externalNP)).name) = "TXL_arguments_"
	result kid4NP(externalNP)
    end external_formalsNP

    function listRepeatOrOptTargetName (listRepeatOrOptNP : nodePT) : string
    	if nodes (kid1NP (kid2NP (listRepeatOrOptNP))).kind = kindT.id then
	    result identTable (nodes (kid1NP (kid2NP (listRepeatOrOptNP))).name)
	else
	    assert literalP (kid1NP (kid2NP (listRepeatOrOptNP)))
	    const literalT : tokenT := literal_tokenT (kid1NP (kid2NP (listRepeatOrOptNP)))
	    result "lit__" + identTable (literalT)
	end if
    end listRepeatOrOptTargetName

    function descriptionTargetT (descriptionNP : nodePT) : tokenT
	% Given a list, repeat, opt or nonterminal description, 
	% return its nonterminal target name
	
	pre identTable (nodes (descriptionNP).name) = "TXL_description_"
     
	const descriptionName := identTable (nodes (kid1NP (descriptionNP)).name)
	
	var identIndex : tokenT

	if descriptionName  = "TXL_listDescription_" then
	    ident.install ("list__" +
		listRepeatOrOptTargetName (kid1NP (descriptionNP)), identIndex)
	elsif descriptionName = "TXL_repeatDescription_" then
	    ident.install ("repeat__" +
		listRepeatOrOptTargetName (kid1NP (descriptionNP)), identIndex)
	elsif descriptionName = "TXL_list1Description_" then
	    ident.install ("list_1_" +
		listRepeatOrOptTargetName (kid1NP (descriptionNP)), identIndex)
	elsif descriptionName = "TXL_repeat1Description_" then
	    ident.install ("repeat_1_" +
		listRepeatOrOptTargetName (kid1NP (descriptionNP)), identIndex)
	elsif descriptionName = "TXL_optDescription_" then
	    ident.install ("opt__" +
		listRepeatOrOptTargetName (kid1NP (descriptionNP)), identIndex)
	else
	    identIndex := nodes (kid1NP (descriptionNP)).name
	end if

	result identIndex

    end descriptionTargetT

    body function rule_targetT % (ruleNP : nodePT) : tokenT
	pre identTable (nodes (ruleNP).name) = "TXL_ruleStatement_" or
	     identTable (nodes (ruleNP).name) = "TXL_functionStatement_" 
     
	const bracketedDescriptionNP := kidNP (7,ruleNP)
	assert identTable (nodes (bracketedDescriptionNP).name) = "TXL_bracketedDescription_"
	const descriptionNP := kid2NP (bracketedDescriptionNP)
	assert identTable (nodes (descriptionNP).name) = "TXL_description_"

	result descriptionTargetT (descriptionNP)
    end rule_targetT

    body function construct_varNameT % (constructNP : nodePT) : tokenT
	pre identTable (nodes (constructNP).name) = "TXL_constructPart_"
	result nodes(kid2NP(constructNP)).name
    end construct_varNameT

    body function construct_targetT% (constructNP : nodePT) : tokenT
	pre identTable (nodes (constructNP).name) = "TXL_constructPart_"

	const bracketedDescriptionNP := kid3NP(constructNP)
	assert identTable (nodes (bracketedDescriptionNP).name) = "TXL_bracketedDescription_"
	const descriptionNP := kid2NP (bracketedDescriptionNP)
	assert identTable (nodes (descriptionNP).name) = "TXL_description_"

	result descriptionTargetT (descriptionNP)
    end construct_targetT

    body function construct_replacementNP% (constructNP : nodePT) : nodePT
	pre identTable (nodes (constructNP).name) = "TXL_constructPart_"
	result kid4NP(constructNP)
    end construct_replacementNP

    body function deconstruct_varNameT% (constructNP : nodePT) : tokenT
	result nodes(kid2NP(constructNP)).name
    end deconstruct_varNameT

    body function deconstruct_patternNP% (constructNP : nodePT) : nodePT
	result kid3NP(constructNP)
    end deconstruct_patternNP

    body function rule_nameT % (ruleNP : nodePT) : tokenT
	pre identTable (nodes (ruleNP).name) = "TXL_ruleStatement_"
	 or identTable (nodes (ruleNP).name) = "TXL_functionStatement_"
	result nodes (kid2NP (ruleNP)).name
    end rule_nameT

    body function rule_prePatternNP % (ruleNP : nodePT) : nodePT
	pre (identTable (nodes (ruleNP).name) = "TXL_ruleStatement_" or
	     identTable (nodes (ruleNP).name) = "TXL_functionStatement_") and
	    identTable (nodes (kid4NP (ruleNP)).name) = "TXL_parts_"
	result kid4NP (ruleNP)
    end rule_prePatternNP

    body function rule_postPatternNP % (ruleNP : nodePT) : nodePT
	pre (identTable (nodes (ruleNP).name) = "TXL_ruleStatement_" or
	     identTable (nodes (ruleNP).name) = "TXL_functionStatement_") and
	    identTable (nodes (kidNP (9,ruleNP)).name) = "TXL_parts_"
	result kidNP (9,ruleNP)
    end rule_postPatternNP

    body function rule_patternNP % (ruleNP : nodePT) : nodePT
	pre (identTable (nodes (ruleNP).name) = "TXL_ruleStatement_" or
	     identTable (nodes (ruleNP).name) = "TXL_functionStatement_" ) and
	    identTable (nodes (kidNP (8,ruleNP)).name) = "TXL_pattern_"
	result kidNP (8,ruleNP)
    end rule_patternNP

    body function rule_replaceOrMatchT % (ruleNP : nodePT) : tokenT
	pre (identTable (nodes (ruleNP).name) = "TXL_ruleStatement_" or
	     identTable (nodes (ruleNP).name) = "TXL_functionStatement_" ) and
	    identTable (nodes (kidNP (6,ruleNP)).name) = "TXL_replaceOrMatch_"
	result nodes (kid1NP (kidNP (6,ruleNP))).name 
    end rule_replaceOrMatchT

    body function rule_optByReplacementNP % (ruleNP : nodePT) : nodePT
	pre (identTable (nodes (ruleNP).name) = "TXL_ruleStatement_" or
	     identTable (nodes (ruleNP).name) = "TXL_functionStatement_" ) and
	    identTable (nodes (kidNP (10,ruleNP)).name) = "TXL_optByReplacement_"
	result kidNP (10,ruleNP)
    end rule_optByReplacementNP

    body function optByReplacement_replacementNP % (optByReplacementNP : nodePT) : nodePT
	pre (identTable (nodes (optByReplacementNP).name) = "TXL_optByReplacement_" and
	    (not plural_emptyP (optByReplacementNP)) and
	    identTable (nodes (kid2NP (kid1NP (optByReplacementNP))).name) = "TXL_replacement_")
	result kid2NP (kid1NP (optByReplacementNP))
    end optByReplacement_replacementNP 

    body function rule_optSkippingNP % (ruleNP : nodePT) : nodePT
	pre (identTable (nodes (ruleNP).name) = "TXL_ruleStatement_" or
	     identTable (nodes (ruleNP).name) = "TXL_functionStatement_" ) and
	    identTable (nodes (kidNP (5,ruleNP)).name) = "TXL_optSkippingBracketedDescription_"
	result kidNP(5,ruleNP)
    end rule_optSkippingNP

    body function optSkipping_nameT % (optSkippingNP : nodePT) : tokenT
	pre identTable (nodes(optSkippingNP).name) = "TXL_optSkippingBracketedDescription_"
	    and identTable (nodes(kid1NP(optSkippingNP)).name) = "TXL_skippingBracketedDescription_"

	const bracketedDescriptionNP := kid2NP(kid1NP(optSkippingNP))
	assert identTable (nodes (bracketedDescriptionNP).name) = "TXL_bracketedDescription_"
	const descriptionNP := kid2NP (bracketedDescriptionNP)
	assert identTable (nodes (descriptionNP).name) = "TXL_description_"

	result descriptionTargetT (descriptionNP)
    end optSkipping_nameT
	
    % How to get from a rule to its formals
    body function rule_formalsNP % (ruleNP : nodePT) : nodePT
	pre (identTable (nodes (ruleNP).name) = "TXL_ruleStatement_" or
	     identTable (nodes (ruleNP).name) = "TXL_functionStatement_" ) and
	    identTable (nodes (kid3NP (ruleNP)).name) = "TXL_arguments_"
	result kid3NP (ruleNP)
    end rule_formalsNP

    % how to get from an argument to its name
    body function formal_nameT % (argumentNP : nodePT) : tokenT
	pre identTable (nodes (argumentNP).name) = "TXL_argument_"
	result nodes (kid1NP (argumentNP)).name
    end formal_nameT

    % how to get from an argument to its type
    body function formal_typeT % (argumentNP : nodePT) : tokenT
	pre identTable (nodes (argumentNP).name) = "TXL_argument_" 

	const bracketedDescriptionNP := kid2NP (argumentNP)
	assert identTable (nodes (bracketedDescriptionNP).name) = "TXL_bracketedDescription_"
	const descriptionNP := kid2NP (bracketedDescriptionNP)
	assert identTable (nodes (descriptionNP).name) = "TXL_description_"

	result descriptionTargetT (descriptionNP)
    end formal_typeT

    body function isQuotedLiteral % (literalNP : nodePT) : boolean
	pre identTable (nodes(literalNP).name) = "TXL_literal_"
	    or identTable (nodes(literalNP).name) = "TXL_expression_"
	    or identTable (nodes(literalNP).name) = "TXL_firstTime_"

	const k1NP : nodePT := cells (nodes (literalNP).kidsCP).firstNP

	result identTable (nodes(literalNP).name) = "TXL_literal_"
	    and identTable (nodes (k1NP).name) = "TXL_quotedLiteral_" 
    end isQuotedLiteral

    body function literal_tokenT % (literalNP : nodePT) : tokenT
	pre identTable (nodes(literalNP).name) = "TXL_literal_"
	    or identTable (nodes(literalNP).name) = "TXL_expression_"
	    or identTable (nodes(literalNP).name) = "TXL_firstTime_"

	const k1NP : nodePT := cells (nodes (literalNP).kidsCP).firstNP

	if nodes (k1NP).kind = kindT.order or nodes (k1NP).kind = kindT.choose then
	    if identTable (nodes (k1NP).name) = "TXL_quotedLiteral_" then
		result nodes (kid1NP (kid2NP (k1NP))).name
	    else
		assert identTable (nodes (literalNP).name) = "TXL_expression_"
		    or identTable (nodes (literalNP).name) = "TXL_firstTime_"
		result nodes (k1NP).name
	    end if
	else
	    % direct token literal
	    result nodes (k1NP).name
	end if
    end literal_tokenT

    body function literal_kindT % (literalNP : nodePT) : kindT
	pre identTable (nodes(literalNP).name) = "TXL_literal_"
	    or identTable (nodes(literalNP).name) = "TXL_expression_"
	    or identTable (nodes(literalNP).name) = "TXL_firstTime_"

	const k1NP : nodePT := cells (nodes (literalNP).kidsCP).firstNP
	const k1kind : kindT := nodes (k1NP).kind

	if k1kind = kindT.order or k1kind = kindT.choose then
	    if identTable (nodes (k1NP).name) = "TXL_quotedLiteral_" then
		result nodes (kid1NP (kid2NP (k1NP))).kind
	    else
		assert identTable (nodes (literalNP).name) = "TXL_expression_"
		    or identTable (nodes (literalNP).name) = "TXL_firstTime_"
		result k1kind
	    end if
	else
	    % direct token literal
	    result k1kind
	end if
    end literal_kindT

    body function ruleCall_nameT % (ruleCallNP : nodePT) : tokenT
	pre identTable (nodes (ruleCallNP).name) = "TXL_ruleCall_"
	result nodes (kid2NP (ruleCallNP)).name
    end ruleCall_nameT

    body function ruleCall_literalsNP % (ruleCallNP : nodePT) : nodePT
	pre identTable (nodes (kid3NP (ruleCallNP)).name) = "TXL_literals_"
	result kid3NP (ruleCallNP)
    end ruleCall_literalsNP

    body function bracketedDescription_idT % (bracketedDescriptionNP : nodePT) : tokenT
	pre identTable (nodes (bracketedDescriptionNP).name) = "TXL_bracketedDescription_"
	    and identTable (nodes (kid2NP (bracketedDescriptionNP)).name) = "TXL_description_"
%	#if not MAC then
	    const descriptionName := identTable (nodes(kid1NP(kid2NP(bracketedDescriptionNP))).name)
	    assert descriptionName ~= "TXL_listDescription_" and descriptionName ~= "TXL_repeatDescription_"
	   	and descriptionName ~= "TXL_list1Description_" and descriptionName ~= "TXL_repeat1Description_"
	    	and descriptionName ~= "TXL_optDescription_"
%	#end if
	result nodes (kid1NP (kid2NP (bracketedDescriptionNP))).name
    end bracketedDescription_idT

    body function bracketedDescription_listRepeatOrOptTargetNP  % (bracketedDescriptionNP : nodePT) : nodePT
	pre identTable (nodes (bracketedDescriptionNP).name) = "TXL_bracketedDescription_"
	    and identTable (nodes (kid2NP (bracketedDescriptionNP)).name) = "TXL_description_"
	const listRepeatOrOptNP := kid1NP(kid2NP(bracketedDescriptionNP))
%	#if not MAC then
	    const listRepeatOrOptName := identTable (nodes(listRepeatOrOptNP).name)
	    assert listRepeatOrOptName  = "TXL_listDescription_" or listRepeatOrOptName = "TXL_repeatDescription_"
	    	or listRepeatOrOptName  = "TXL_list1Description_" or listRepeatOrOptName  = "TXL_repeat1Description_"
	    	or listRepeatOrOptName  = "TXL_optDescription_"
%	#end if
	result kid2NP (listRepeatOrOptNP)
    end bracketedDescription_listRepeatOrOptTargetNP

    body function firstTime_nameT % (firstTimeNP : nodePT) : tokenT
	pre identTable (nodes (firstTimeNP).name) = "TXL_firstTime_"
	result nodes (kid1NP (firstTimeNP)).name
    end firstTime_nameT

    body function firstTime_typeT % (firstTimeNP : nodePT) : tokenT
	pre identTable (nodes (firstTimeNP).name) = "TXL_firstTime_"

	const descriptionNP : nodePT := kid3NP (firstTimeNP)
	assert identTable (nodes (descriptionNP).name) = "TXL_description_"

	result descriptionTargetT (descriptionNP)
    end firstTime_typeT

    body function expression_baseT % (expressionNP : nodePT) : tokenT
	pre identTable (nodes (expressionNP).name) = "TXL_expression_"
	result nodes (kid1NP (expressionNP)).name
    end expression_baseT

    body function expression_ruleCallsNP % (expressionNP : nodePT) : nodePT
	pre identTable (nodes (kid2NP (expressionNP)).name) = "TXL_ruleCalls_"
	result kid2NP (expressionNP)
    end expression_ruleCallsNP

    body function program_statementsNP % (programNP : nodePT) : nodePT
	pre identTable (nodes (kid1NP (programNP)).name) = "TXL_statements_"
	result kid1NP (programNP)
    end program_statementsNP

    body function keys_literalsNP % (keyListNP : nodePT) : nodePT
	pre identTable (nodes (kid2NP (keyListNP)).name) = "TXL_literals_"
	result kid2NP (keyListNP)
    end keys_literalsNP

    body function define_nameT % (defineNP : nodePT) : tokenT
        result nodes (kid2NP (defineNP)).name
    end define_nameT

    body function define_literalsAndBracketedIdsNP % (defineNP : nodePT) : nodePT
	pre identTable (nodes (defineNP).name) = "TXL_defineStatement_"
        result kid3NP (defineNP)
    end define_literalsAndBracketedIdsNP

    body function define_barOrdersNP % (defineNP : nodePT) : nodePT
	pre identTable (nodes (defineNP).name) = "TXL_defineStatement_"
        result kid4NP (defineNP)
    end define_barOrdersNP

    body function statement_keyDefRuleNP % (statementNP : nodePT) : nodePT
	pre identTable (nodes (statementNP).name) = "TXL_statement_"
	result kid1NP (statementNP)
    end statement_keyDefRuleNP

    body function condition_expressionNP % (conditionNP : nodePT) : nodePT
        pre identTable (nodes (conditionNP).name) = "TXL_conditionPart_"
            and identTable (nodes (kid2NP (conditionNP)).name) = "TXL_expression_"
        result kid2NP (conditionNP)
    end condition_expressionNP

    body function isListOrRepeat % (listOrRepeatNP : nodePT) : boolean
	bind name to identTable (nodes (listOrRepeatNP).name)
	if type (char, name) = 'r' then
	    result type (char (7), name) = 'repeat_' 
	elsif type (char, name) = 'l' then
	    result type (char (5), name) = 'list_'
	else
	    result false
	end if
    end isListOrRepeat

    body function lengthListOrRepeat % (listOrRepeatNP : nodePT) : int
	pre isListOrRepeat (listOrRepeatNP)
	bind name to type (char (8), identTable (nodes (listOrRepeatNP).name))

	if name (1) = 'l' then
	    if nodes (kid1NP (listOrRepeatNP)).kind = kindT.empty then
		result 0
	    else
		var listCount := 1
		var runNP : nodePT

		if name (6) = '1' then
		    runNP := kid2NP (listOrRepeatNP)
		else
		    runNP := kid2NP (kid1NP (listOrRepeatNP))
		end if

		loop
		    exit when plural_emptyP (runNP)
		    % Remember you'll be dealing with subsequent uses here.
		    listCount += 1
		    runNP := kid2NP (kid2NP (kid1NP (runNP)))
		end loop

		result listCount
	    end if

	else
	    assert name (1) = 'r'

	    if nodes (kid1NP (listOrRepeatNP)).kind = kindT.empty then
		result 0
	    else
		var repeatCount := 1
		var runNP : nodePT

		if name (8) = '1' then
		    runNP := kid2NP (listOrRepeatNP)
		else
		    runNP := kid2NP (kid1NP (listOrRepeatNP))
		end if

		loop
		    exit when plural_emptyP (runNP)
		    repeatCount += 1
		    runNP := plural_restNP (runNP)
		end loop

		result repeatCount
	    end if
	end if
    end lengthListOrRepeat

    body function listOrRepeatFirstNP % (listOrRepeatNP : nodePT) : nodePT
	pre isListOrRepeat (listOrRepeatNP)
	bind name to type (char (8), identTable (nodes (listOrRepeatNP).name))

	if name (1) = 'l' then
	    if name (6) = '1' then
		% list_1_X
		result kid1NP (listOrRepeatNP)
	    elsif name (6) = 'o' then
		% list_opt_rest_X
		result kid1NP (kid2NP (kid1NP (listOrRepeatNP)))
	    else
		% list__X
		result kid1NP (kid1NP (listOrRepeatNP))
	    end if
	else
	    assert name (1) = 'r'
	    if name (8) = '1' then
		% repeat_1_X
		result kid1NP (listOrRepeatNP)
	    else
		% repeat__X
		result kid1NP (kid1NP (listOrRepeatNP))
	    end if
	end if
    end listOrRepeatFirstNP

    body function listOrRepeatRestNP % (listOrRepeatNP : nodePT) : nodePT
	pre isListOrRepeat (listOrRepeatNP)
	bind name to type (char (8), identTable (nodes (listOrRepeatNP).name))

	if name (1) = 'l' then
	    if name (6) = '1' then
		% list_1_X
		result kid2NP (listOrRepeatNP)
	    elsif name (6) = 'o' then
		% list_opt_rest_X
		result kid2NP (kid2NP (kid1NP (listOrRepeatNP)))
	    else
		% list__X
		result kid2NP (kid1NP (listOrRepeatNP))
	    end if
	else
	    assert name (1) = 'r'
	    if name (8) = '1' then
		% repeat_1_X
		result kid2NP (listOrRepeatNP)
	    else
		% repeat__X
		result kid2NP (kid1NP (listOrRepeatNP))
	    end if
	end if
    end listOrRepeatRestNP

    body function isListOrRepeatType % (listOrRepeatType : tokenT) : boolean
 	var typeName := identTable (listOrRepeatType)
	result typeName (1..5) = "list_" or typeName (1..7) = "repeat_"
    end isListOrRepeatType 

    body function listOrRepeatBaseType % (listOrRepeatType: tokenT) : tokenT
	pre isListOrRepeatType (listOrRepeatType)

 	var typeName := identTable (listOrRepeatType)
	const tname : char (8) := typeName (1 .. 8)

	if tname (1) = 'l' then
	    if tname (6) = '1' then
		% list_1_X
		typeName := typeName (8 .. *)
	    else
		% list__X
		typeName := typeName (7 .. *)
	    end if
	else
	    assert tname (1) = 'r'
	    if tname (8) = '1' then
		% repeat_1_X
		typeName := typeName (10 .. *)
	    else
		% repeat__X
		typeName := typeName (9 .. *)
	    end if
	end if

	var identIndex : tokenT
	ident.install (typeName, identIndex)
	result identIndex
    end listOrRepeatBaseType

    body function sameTrees % (tree1NP, tree2NP : nodePT) : boolean
	case nodes (tree1NP).kind of
	    label kindT.empty :
		result nodes (tree2NP).kind = kindT.empty

	    label kindT.order, kindT.choose :
		if nodes (tree1NP).name = nodes (tree2NP).name and
			nodes (tree1NP).kind = nodes (tree2NP).kind then
		    var tree1KidsCP := nodes (tree1NP).kidsCP
		    var tree2KidsCP := nodes (tree2NP).kidsCP
		    var same := true
		    loop
			exit when tree1KidsCP = nilCell or tree2KidsCP = nilCell

			same := same and 
			    sameTrees (cells (tree1KidsCP).firstNP, cells (tree2KidsCP).firstNP)

			exit when not same

			tree1KidsCP := cells (tree1KidsCP).restCP
			tree2KidsCP := cells (tree2KidsCP).restCP
		    end loop

		    result same and
			tree1KidsCP = nilCell and tree2KidsCP = nilCell
		else
		    result false
		end if

	    label kindT.literal, kindT.stringlit, kindT.charlit, kindT.token, kindT.key,
		    kindT.number, kindT.floatnumber,
		    kindT.decimalnumber, kindT.integernumber,
		    kindT.id, kindT.upperlowerid, kindT.upperid,
		    kindT.lowerupperid, kindT.lowerid :
		result nodes (tree1NP).kind = nodes (tree2NP).kind and
		    nodes (tree1NP).name = nodes (tree2NP).name

	    label :
		% other nodes illegal in parse trees
		error ("Fatal TXL error in sameTrees", FATAL)
	end case

	result false
    end sameTrees

    body function literalOrBracketedIdP % (nodeP : nodePT) : boolean
	result identTable (nodes (nodeP).name) = "TXL_literalOrBracketedDescription_"
    end literalOrBracketedIdP

    body function bracketedDescriptionP % (nodeP : nodePT) : boolean
	result identTable (nodes (nodeP).name) = "TXL_bracketedDescription_"
    end bracketedDescriptionP

    body function quotedLiteralP % (nodeP : nodePT) : boolean
	result identTable (nodes (nodeP).name) = "TXL_quotedLiteral_"
    end quotedLiteralP

    body function literalP % (nodeP : nodePT) : boolean
	result identTable (nodes (nodeP).name) = "TXL_literal_"
    end literalP

    body function listP % (bracketedDescriptionNP : nodePT) : boolean
	result identTable (nodes (kid1NP (kid2NP (bracketedDescriptionNP))).name)
	    = "TXL_listDescription_"
    end listP

    body function repeatP % (bracketedDescriptionNP : nodePT) : boolean
	result identTable (nodes (kid1NP (kid2NP (bracketedDescriptionNP))).name)
	    = "TXL_repeatDescription_"
    end repeatP

    body function list1P % (bracketedDescriptionNP : nodePT) : boolean
	result identTable (nodes (kid1NP (kid2NP (bracketedDescriptionNP))).name)
	    = "TXL_list1Description_"
    end list1P

    body function repeat1P % (bracketedDescriptionNP : nodePT) : boolean
	result identTable (nodes (kid1NP (kid2NP (bracketedDescriptionNP))).name)
	    = "TXL_repeat1Description_"
    end repeat1P

    body function optP % (bracketedDescriptionNP : nodePT) : boolean
	result identTable (nodes (kid1NP (kid2NP (bracketedDescriptionNP))).name)
	    = "TXL_optDescription_"
    end optP

    body function nodeIsTypeP % (nodeP : nodePT, typeT : tokenT) : boolean
	if nodes (nodeP).name = typeT then
	    % identical - exact match
	    result true
	else
	    bind typeName to identTable (typeT)

	    case nodes (nodeP).kind of
		label kindT.stringlit:
		    result typeName = "stringlit"
		label kindT.charlit:
		    result typeName = "charlit"
		label kindT.token:
		    result typeName = "token"
		label kindT.key:
		    result typeName = "key"
		label kindT.number:
		    result typeName = "number"
		label kindT.floatnumber:
		    result typeName = "floatnumber"
		label kindT.decimalnumber:
		    result typeName = "decimalnumber"
		label kindT.integernumber:
		    result typeName = "integernumber"
		label kindT.id:
		    result typeName = "id"
		label kindT.upperlowerid:
		    result typeName = "upperlowerid"
		label kindT.upperid:
		    result typeName = "upperid"
		label kindT.lowerupperid:
		    result typeName = "lowerupperid"
		label kindT.lowerid :
		    result typeName = "lowerid"
		label kindT.empty :
		    result typeName = "empty" or typeName = "emptyString"
		label :
		    result false
	    end case
	end if
    end nodeIsTypeP

    body function literalTypeName % (kind : kindT) : tokenT
	var typeName : tokenValueT 
	case kind of
	    label kindT.stringlit:
		typeName := "stringlit"
	    label kindT.charlit:
		typeName := "charlit"
	    label kindT.token:
		typeName := "token"
	    label kindT.key:
		typeName := "key"
	    label kindT.number:
		typeName := "number"
	    label kindT.floatnumber:
		typeName := "floatnumber"
	    label kindT.decimalnumber:
		typeName := "decimalnumber"
	    label kindT.integernumber:
		typeName := "integernumber"
	    label kindT.id:
		typeName := "id"
	    label kindT.upperlowerid:
		typeName := "upperlowerid"
	    label kindT.upperid:
		typeName := "upperid"
	    label kindT.lowerupperid:
		typeName := "lowerupperid"
	    label kindT.lowerid :
		typeName := "lowerid"
	    label kindT.empty :
		typeName := "empty"
	    label :
		typeName := ""
		assert false
	end case
	var identIndex : tokenT
	ident.install (typeName, identIndex)
	result identIndex
    end literalTypeName

    procedure copyKids (originalCP : cellPT, var copyCP : cellPT)
        if originalCP = nilCell then
	    copyCP := nilCell
	else
	    newCell (copyCP)
	    copyTree (cells (originalCP).firstNP, cells (copyCP).firstNP)
	    copyKids (cells (originalCP).restCP, cells (copyCP).restCP)
	end if
    end copyKids

    body procedure copyTree % (originalNP : nodePT, var copyNP : nodePT)
	pre originalNP not= nilNode

	% optimize by sharing all literals 
	case nodes (originalNP).kind of

	    label
		% These are always ok.
		    kindT.empty, kindT.literal, kindT.key, kindT.token,
		% These depend on nodes passed to external rules 
		% (which may change the values in a node) being explicitly copied!
		    kindT.stringlit, kindT.charlit, kindT.number, kindT.floatnumber, 
		    kindT.decimalnumber, kindT.integernumber,
		    kindT.id, kindT.upperlowerid, kindT.upperid,
		    kindT.lowerupperid, kindT.lowerid,
		% These depend on the fact that the transformer
		% does not actually change the original node values 
		% when matching patterns.
		    kindT.firstTime, kindT.subsequentUse,
		% These depend on the fact that the transformer
		% does not actually subsitute anything into a rule call
		% subtree when implementing the call.
		    kindT.expression, kindT.ruleCall :
		copyNP := originalNP

	    label kindT.order, kindT.choose :
		% These cannot be blindly shared, and in general have children
		newNode (copyNP)
		nodes (copyNP) := nodes (originalNP)
		copyKids (nodes (originalNP).kidsCP, nodes (copyNP).kidsCP)

	    label kindT.undefined :
		error ("TXL Fatal error in copyTree", FATAL)
	end case

    end copyTree

end trees
include "rule_table.i"
% TXL v6.0 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% The TXL Rule Table

type * localsListT :
    record
	local : array 1 .. maxLocalVars of
	    record
		name : tokenT
		typename : tokenT
		valueNP : nodePT
		refs : nat2
	    end record
	nformals, nprelocals, nlocals : 0 .. maxLocalVars
    end record

type * partKind : packed enum (construct, deconstruct, cond, none)

type * partDescriptor :
    record
        kind : partKind
        name : tokenT
        nameRef : 0 .. maxLocalVars
        target : tokenT
        replacementNP : nodePT
        patternNP : nodePT
    end record

type * partList : array 1 .. maxParts of partDescriptor

type * ruleT :
    record
        name : tokenT 
        localVars : localsListT
        targetName : tokenT
        targetKind : kindT
        skipName : tokenT
        prePatternCount : 0 .. maxParts
        prePattern : partList
        patternNP : nodePT
        postPatternCount : 0 .. maxParts
        postPattern : partList
        replacementNP : nodePT
        isFunctionRule : boolean
        isExternalRule : boolean
        isCondition : boolean
        hasPostCondition : boolean
	defined : boolean
	called : boolean
    end record

%#if MAC then
%    % get around MPW C limitations by using a dynamically allocated array
%    var dynamicMaxNumRules := maxRules
%    var rules : array 1 .. dynamicMaxNumRules of ruleT
%#else
    var rules : array 1 .. maxRules of ruleT
%#end if

type * ruleIndexT : 1 .. maxRules

var ruleIndex : array 1 .. maxRules of ruleIndexT

var ruleCount := 0


% Operations on the Rule Table

procedure enterRuleName (ruleName : tokenT, var resultIndex : int)
    if ruleCount = maxRules then
	error ("In TXL specification, too many rule definitions.\n" +
	    "  (> " + intstr (maxRules, 1) + ")", FATAL)
    end if

    for r : 1 .. ruleCount
	if rules (r).name = ruleName then
	    resultIndex := r
	    return
	end if
    end for

    ruleCount += 1
    rules (ruleCount).name := ruleName
    rules (ruleCount).hasPostCondition := false
    rules (ruleCount).defined := false
    rules (ruleCount).called := false
    ruleIndex (ruleCount) := ruleCount
    resultIndex := ruleCount
end enterRuleName


procedure lookupLocalVar (arg_localVars : localsListT, varName : tokenT, var varIndex : int)

    bind register localVars to arg_localVars

    for i : 1 .. localVars.nlocals 
	if localVars.local (i).name = varName then
	    varIndex := i
	    return
	end if
    end for

    varIndex := 0
end lookupLocalVar


procedure findLocalVar (arg_localVars : localsListT, varName : tokenT, var varIndex : int)

    bind register localVars to arg_localVars

    for i : 1 .. localVars.nlocals 
	if localVars.local (i).name = varName then
	    varIndex := i
	    return
	end if
    end for

    error ("In TXL specification, local variable '" + identTable (varName) + 
	"' has not been defined", FATAL)
end findLocalVar


procedure enterLocalVar (var arg_localVars : localsListT, 
	varName : tokenT, varType : tokenT, var varIndex : int)

    bind var register localVars to arg_localVars

    for i : 1 .. localVars.nformals
	if localVars.local (i).name = varName then
	    error ("In TXL specification, local variable '" + identTable (varName) + 
		"' has already been defined as a rule parameter.", FATAL)
	end if
    end for

    for i : localVars.nformals + 1 .. localVars.nlocals
	if localVars.local (i).name = varName then
	    varIndex := i
	    return
	end if
    end for

    if localVars.nlocals < maxLocalVars then
	localVars.nlocals += 1
	varIndex := localVars.nlocals
	bind var localVar to localVars.local (localVars.nlocals)
	localVar.name := varName
	localVar.typename := varType
	localVar.valueNP := nilNode
	localVar.refs := 0
    else
	error ("In TXL specification, too many local vars.\n" +
	    "  (> " + intstr (maxLocalVars, 1) + ")", FATAL)
    end if
end enterLocalVar


% Predefined 'not' and 'fail' rule table entries 
const * numPredefinedRules := 2
var failRule, notRule : tokenT	
begin
    var rule : int
    ident.install ("fail", failRule)
    enterRuleName (failRule, rule)
    begin
	bind var r to rules (rule)
	r.localVars.nformals := 0
	r.localVars.nprelocals := 0
	r.localVars.nlocals := 0
	r.targetName := NOT_FOUND
	r.skipName := NOT_FOUND
	r.prePatternCount := 0
	r.patternNP := nilNode
	r.postPatternCount := 0
	r.replacementNP := nilNode
        r.isFunctionRule := false
        r.isExternalRule := false
        r.isCondition := false
	r.called := false
	r.defined := true
    end
    ident.install ("not", notRule)
    enterRuleName (notRule, rule)
    begin
	bind var r to rules (rule)
	r.localVars.nformals := 0
	r.localVars.nprelocals := 0
	r.localVars.nlocals := 0
	r.targetName := NOT_FOUND
	r.skipName := NOT_FOUND
	r.prePatternCount := 0
	r.patternNP := nilNode
	r.postPatternCount := 0
	r.replacementNP := nilNode
        r.isFunctionRule := false
        r.isExternalRule := false
        r.isCondition := true
	r.called := false
	r.defined := true
    end
end
assert ruleCount = numPredefinedRules

include "symbol_table.i"
% TXL v5.3 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% TXL Symbol Table

% TXL specification symbol table - not used for TXL bootstrap,
% which has its own private table
var symbolTable : array 1 .. maxSymbols of nodePT
var symbolTableSize := 0
const * UNDEFINED := - 1

% Uninitialized node for setting up new symbols
var uninitializedNP : nodePT
newNode (uninitializedNP)
begin
    var uninitializedSymbolT : tokenT
    ident.install ("_uninitialized_symbol_", uninitializedSymbolT)
    nodes (uninitializedNP).name := uninitializedSymbolT
    nodes (uninitializedNP).kind := kindT.undefined
    nodes (uninitializedNP).count := 0
    nodes (uninitializedNP).kidsCP := nilCell
end

% Symbol Table Operations

procedure enterSymbol (partId : tokenT, var symbolIndex : int)
    for p : 1 .. symbolTableSize
        if nodes (symbolTable (p)).name = partId then
            symbolIndex := p
            return
        end if
    end for

    if symbolTableSize = maxSymbols then
	error ("Too many defined symbols (> " + intstr (maxSymbols, 1) + ")", FATAL)
    end if

    symbolTableSize += 1
    symbolIndex := symbolTableSize
    newNode (symbolTable (symbolIndex))
    nodes (symbolTable (symbolIndex)) := nodes (uninitializedNP)
    nodes (symbolTable (symbolIndex)).name := partId
end enterSymbol


procedure lookupSymbol (partId : tokenT, var symbolIndex : int)
    % returns UNDEFINED if symbol is not defined
    for p : 1 .. symbolTableSize
        if nodes (symbolTable (p)).name = partId then
            symbolIndex := p
            return
        end if
    end for

    symbolIndex := UNDEFINED
end lookupSymbol


procedure findSymbol (partId : tokenT, var symbolIndex : int)
    for p : 1 .. symbolTableSize
        if nodes (symbolTable (p)).name = partId then
            symbolIndex := p
            return
        end if
    end for

    error ("Symbol " + identTable (partId) + " has not been defined", FATAL)
end findSymbol
include "shared.i"
% TXL v5.3 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% Shared global common names and nodes
var sharedT : tokenT
var sharedNP : nodePT

procedure initializeSharedNode (name : string, kind : kindT) 
    newNode (sharedNP)
    ident.install (name, sharedT)
    nodes (sharedNP).name := sharedT
    nodes (sharedNP).kind := kind
    nodes (sharedNP).count := 0
    nodes (sharedNP).kidsCP := nilCell
end initializeSharedNode

% empty
initializeSharedNode ("empty", kindT.empty)
const * emptyT := sharedT
const * emptyNP := sharedNP

% comma
initializeSharedNode (",", kindT.literal)
const * commaT := sharedT
const * commaNP := sharedNP

% NL
initializeSharedNode ("NL", kindT.empty)
const * NL_T := sharedT
const * NL_NP := sharedNP

% IN
initializeSharedNode ("IN", kindT.empty)
const * IN_T := sharedT
const * IN_NP := sharedNP

% EX
initializeSharedNode ("EX", kindT.empty)
const * EX_T := sharedT
const * EX_NP := sharedNP

% SP
initializeSharedNode ("SP", kindT.empty)
const * SP_T := sharedT
const * SP_NP := sharedNP

% SPOFF
initializeSharedNode ("SPOFF", kindT.empty)
const * SPOFF_T := sharedT
const * SPOFF_NP := sharedNP

% SPON
initializeSharedNode ("SPON", kindT.empty)
const * SPON_T := sharedT
const * SPON_NP := sharedNP

% check that we haven't violated TXL compiling limits
assert cellCount < 10
assert nodeCount < 10
include "options.i"
% TXL v6.0 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% Debugging option flags

var parse_print_p, apply_print_p, node_print_p, rule_print_p,
    tree_print_p, boot_parse_p, verbose_p, compile_p, load_p, 
    debug_p, grammar_print_p, raw_p, txl_p, tuning_p,
    no_comment_p := false

% Command line specified file names
var bootFileName, txlSourceFileName, 
    txlCompiledFileName, objectSourceFileName := ""

% Command line handling

include "%system"
%
%	Computer Systems Research Group
%   	University of Toronto
  
%	Turing VAX/Unix System Routines V1.0
%   	Author:	Mark Mendell
%   	Date:	January 1984

% Copyright (C) 1984  The University of Toronto

% This module provides an interface to the Turing System routines.
% This module should be included in the user's program
% using the include statement:

%	include "%system"

% and compiled with the production Turing compiler (pttc).

%
% Return the number of arguments on the command line.
% E.g. for t.x y, nargs returns 1.
%
    external "TL_TLI_TLIARC" var nargs : int

%
% Return the i'th argument from the command line.  The 0'th
% argument is the command name.  0 <= i <= nargs.  The argument may be
% truncated to fit.
%
    external "TL_TLI_TLIFA" function fetcharg (i : int) : string

%
% Get the value of a UNIX environment variable.  The value may be
% truncated to fit.
%
    external "TLXGE" function getenv (symbol : string) : string

%
% Assigns the current date to the variable d in the format
% "dd mmm yy", where mmm is the first 3 characters of the month,
% i.e. "Apr".
    external "TLXDT" procedure date (var d : string)


%
% Assigns the current time to the variable t in the format "hh:mm:ss".
%
    external "TLXTM" procedure time (var t : string)

%
% Assigns the number of central processor milliseconds of user time
% used by this process to the variable c.
%
    external "TLXCL" procedure clock (var c : int)

%
% Assigns the number of central processor milliseconds of system time
% used by this process to the variable c.
%
    external "TLXSC" procedure sysclock (var c : int)

%
% Assigns the time in seconds since 00:00:00 GMT January 1, 1970 to
% the variable c.
%
    external "time" procedure wallclock (var c : int)

%
% Executes the shell command str, as if it was typed at the terminal.
% ret is assigned the return code from the command.  ret := 127 if
% the shell cannot be executed.  /bin/sh is used for the execution
%
    external "TLXSYS" procedure system (str : string, var ret : int)

%
% Return the process id of the current UNIX process
%
    external function getpid : int

%
% Flush all buffered output streams.
%
    external "TL_TLI_TLIFS" procedure flushstreams

%
% Terminate the Turing program with a given exit code
%
    external "exit" procedure sysexit (exitcode : int)

%
% Give the elapsed simulated time
%
    external "TL_TLK_TLKCLK" var simutime : nat

%
% Dump the state of all processes
%
    external "TL_TLK_TLKOS" procedure dumpstate

procedure help
    put : 0, ""
    put : 0, "TXL processor options are:"
    put : 0, ""
    put : 0, "  -help:	print out TXL options"
    put : 0, "  -v:	 	use verbose progress messages"
    put : 0, "  -b bootfile:	bootstrap TXL grammar from specified file"
    put : 0, "  -c ctxlfile:	compile only and store compiled result in specified file"
    put : 0, "  -l ctxlfile:	load and run previously compiled TXL file"
    put : 0, "  -debug: 	enable interactive rule debugger (if installed)"
    put : 0, "  -raw: 		produce raw (unspaced) output text"
    put : 0, ""
    put : 0, "Additional debugging options:"
    put : 0, ""
    put : 0, "  -Dbootparse: 	print bootstrap parse trees"
    put : 0, "  -Dgrammar: 	print grammar tree"
    put : 0, "  -Dparse: 	print parse trees"
    put : 0, "  -Dnodes: 	print the nodes as we parse the trees (verbose)"
    put : 0, "  -Dapply: 	print rule applications"
    put : 0, "  -Dtuning: 	print subtree sharing information"
    put : 0, "  -Drules: 	print rule names as we apply rules"
    put : 0, "  -Dtree: 	print final result tree"
    put : 0, "  -Dall:	turn on all of the above -D options (deadly verbose)"
    put : 0, ""
end help

procedure getOptions 
    var argcount := nargs
    var argnum := 1
    loop
        exit when argnum > argcount

        var arg := fetcharg (argnum)

        if length (arg) >= 2 and arg (1 .. 2) = "-D" then

	    arg := arg (3 .. *)

            if arg = "parse" then
                parse_print_p := true
	    elsif arg = "grammar" then
		grammar_print_p := true
            elsif arg = "apply" then
                apply_print_p := true
            elsif arg = "tuning" then
                tuning_p := true
            elsif arg = "node" or arg = "nodes" then
                node_print_p := true
            elsif arg = "rule" or arg = "rules" then
                rule_print_p := true
            elsif arg = "tree" then
                tree_print_p := true
            elsif arg = "bootparse" then
                boot_parse_p := true
            elsif arg = "all" then
                parse_print_p := true
                apply_print_p := true
                node_print_p := true
                rule_print_p := true
                tree_print_p := true
            else
                help
                quit
            end if

	elsif arg = "-debug" then
	    debug_p := true

	elsif arg = "-raw" then
	    raw_p := true

	elsif arg = "-txl" then
	    txl_p := true

	elsif arg = "-nocomment" then
	    no_comment_p := true

        elsif arg = "-v" then
            verbose_p := true

        elsif arg = "-b" then
	    argnum += 1
	    if argnum <= argcount then
		bootFileName := fetcharg (argnum)
	    end if

        elsif arg = "-c" then
	    argnum += 1
	    if argnum <= argcount then
		compile_p := true
		txlCompiledFileName := fetcharg (argnum)
	    end if

        elsif arg = "-l" then
	    argnum += 1
	    if argnum <= argcount then
		load_p := true
		txlCompiledFileName := fetcharg (argnum)
	    end if

        elsif arg = "" or arg (1) = "-" then
            help
            quit

        else
            if txlSourceFileName = "" then
                txlSourceFileName := arg
            elsif objectSourceFileName = "" then
                objectSourceFileName := arg
            else
                error ("Too many command line arguments", FATAL)
            end if
        end if

        argnum += 1
    end loop
end getOptions
include "print_ops.i"
% TXL v6.0 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% TXL tree printing operations

forward procedure printParse (parseNP : nodePT, indentation : int,
    roman_p : boolean)
import (nodes, kindT, trees, forward printKids, identTable,
    forward printTypedNode)

forward procedure printKids (kidsCP : cellPT, indentation : int,
    roman_p : boolean)
import (cells, nodes, printParse)


procedure printTypedNode (parseNP : nodePT)
    const nodeName := identTable (nodes (parseNP).name)

    case nodes (parseNP).kind of
        label kindT.order :
            put : 0, "[", nodeName, "]" ..
        label kindT.choose :
            put : 0, "[", nodeName, "]" ..
	label kindT.empty :
	    if nodeName = "NL" then
		put : 0, "[NL]" ..
	    elsif nodeName = "IN" then
		put : 0, "[IN]" ..
	    elsif nodeName = "EX" then
		put : 0, "[EX]" ..
	    elsif nodeName = "SP" then
		put : 0, "[SP]" ..
	    elsif nodeName = "SPOFF" then
		put : 0, "[SPOFF]" ..
	    elsif nodeName = "SPON" then
		put : 0, "[SPON]" ..
	    else
		put : 0, "[empty]" ..
	    end if
        label kindT.literal :
	    put : 0, "[literal] ", nodeName ..
        label kindT.stringlit :
            put : 0, "[stringlit] ", nodeName ..
        label kindT.charlit :
            put : 0, "[charlit] ", nodeName ..
        label kindT.number :
            put : 0, "[number] ", nodeName ..
        label kindT.floatnumber :
            put : 0, "[floatnumber] ", nodeName ..
        label kindT.decimalnumber :
            put : 0, "[decimalnumber] ", nodeName ..
        label kindT.integernumber :
            put : 0, "[integernumber] ", nodeName ..
        label kindT.id :
            put : 0, "[id] ", nodeName ..
        label kindT.upperlowerid :
            put : 0, "[upperlowerid] ", nodeName ..
        label kindT.upperid :
            put : 0, "[upperid] ", nodeName ..
        label kindT.lowerupperid :
            put : 0, "[lowerupperid] ", nodeName ..
        label kindT.lowerid :
            put : 0, "[lowerid] ", nodeName ..
        label kindT.token :
            put : 0, "[token] ", nodeName ..
        label kindT.key :
            put : 0, "[key] ", nodeName ..
        label kindT.firstTime :
            put : 0, "[firstTime] ", nodeName ..
        label kindT.subsequentUse :
            put : 0, "[subsequentUse] ", nodeName ..
        label kindT.expression :
            put : 0, "[expression] ", nodeName ..
        label kindT.ruleCall :
            put : 0, "[ruleCall] ", nodeName ..
    end case
end printTypedNode


body procedure printParse % (parseNP : nodePT, indentation: int, roman_p : boolean)
    
    if parseNP = nilNode then
	return
    end if

    var i := indentation

    if roman_p then
	loop
	    exit when i <= 0
	    if i > 100 then
		put : 0, "C " ..
		i -= 100
	    elsif i > 50 then
		put : 0, "L " ..
		i -= 50
	    elsif i > 10 then
		put : 0, "X " ..
		i -= 10
	    else
		put : 0, ". " ..
		i -= 1
	    end if
	end loop
    else
	loop
	    exit when i <= 0
	    put : 0, ". " ..
	    i -= 1
	end loop
    end if

    printTypedNode (parseNP)
    put : 0, ""

    case nodes (parseNP).kind of
	label kindT.order :
	    printKids (nodes (parseNP).kidsCP, indentation + 1, roman_p)
	label kindT.choose :
	    printKids (nodes (parseNP).kidsCP, indentation + 1, roman_p)
	label kindT.expression :
	    printKids (nodes (parseNP).kidsCP, indentation + 1, roman_p)
	label kindT.ruleCall :
	    printKids (nodes (parseNP).kidsCP, indentation + 1, roman_p)
	label :
    end case
end printParse


body procedure printKids % (kidsCP: cellPT, indentation: int, roman_p: boolean)
    var kidsLeftCP := kidsCP
    loop
	exit when kidsLeftCP = nilCell
	printParse (cells (kidsLeftCP).firstNP, indentation, roman_p)
	kidsLeftCP := cells (kidsLeftCP).restCP
    end loop
end printKids


var grammarLength := 0
var grammarList : array 1 .. maxSymbols of nodePT


forward procedure printGrammar (grammarNP : nodePT, indentation : int,
    roman_p : boolean)
import (nodes, kindT, trees, forward printGrammarKids, identTable,
    printTypedNode, var grammarLength, var grammarList)

forward procedure printGrammarKids (kidsCP : cellPT, indentation : int,
    roman_p : boolean)
import (cells, nodes, printGrammar)


body procedure printGrammar % (grammarNP : nodePT, indentation: int, roman_p : boolean)
    
    if grammarNP = nilNode then
	return
    end if

    var i := indentation

    if roman_p then
	loop
	    exit when i <= 0
	    if i >= 100 then
		put : 0, "C " ..
		i -= 100
	    elsif i >= 50 then
		put : 0, "L " ..
		i -= 50
	    elsif i >= 10 then
		put : 0, "X " ..
		i -= 10
	    else
		put : 0, ". " ..
		i -= 1
	    end if
	end loop
    else
	loop
	    exit when i <= 0
	    put : 0, ". " ..
	    i -= 1
	end loop
    end if

    printTypedNode (grammarNP)

    if nodes (grammarNP).kind = kindT.choose or
	    nodes (grammarNP).kind = kindT.order then
	% if we've already printed it once, then don't do it again
	for gl : 1 .. grammarLength
	    if grammarNP = grammarList (gl) then
		put : 0, " \^", gl
		return
	    end if
	end for
	grammarLength += 1
	grammarList (grammarLength) := grammarNP
	put : 0, " :", grammarLength ..
    end if

    put : 0, ""

    case nodes (grammarNP).kind of
	label kindT.order :
	    printGrammarKids (nodes (grammarNP).kidsCP, indentation + 1, roman_p)
	label kindT.choose :
	    printGrammarKids (nodes (grammarNP).kidsCP, indentation + 1, roman_p)
	label kindT.expression :
	    printGrammarKids (nodes (grammarNP).kidsCP, indentation + 1, roman_p)
	label kindT.ruleCall :
	    printGrammarKids (nodes (grammarNP).kidsCP, indentation + 1, roman_p)
	label :
    end case
end printGrammar


body procedure printGrammarKids % (kidsCP: cellPT, indentation: int, roman_p: boolean)
    var kidsLeftCP := kidsCP
    loop
	exit when kidsLeftCP = nilCell
	printGrammar (cells (kidsLeftCP).firstNP, indentation, roman_p)
	kidsLeftCP := cells (kidsLeftCP).restCP
    end loop
end printGrammarKids



% Output paragraphing parameters

const indentIncrement := 4
const maxIndent := 40
const tempIndent := indentIncrement div 2
var indent := 0

var emptyLine, blankLine := true
var lastLeafNameEnd : char := ' '
const maxOutputLineLength := 80
var lineLength := 0
var spacing := true


% Spacing tables

const spaceBeforeP : array chr (0) .. chr (255) of boolean := init (T,F)
%%    /*nul*/ T, /*soh*/ T, /*stx*/ T, /*etx*/ T, /*eot*/ T, /*enq*/ T, /*ack*/ T, /*bel*/ T,
%%    /*bs */ T, /*ht */ T, /*nl */ T, /*vt */ T, /*np */ T, /*cr */ T, /*so */ T, /*si */ T,
%%    /*dle*/ T, /*dc1*/ T, /*dc2*/ T, /*dc3*/ T, /*dc4*/ T, /*nak*/ T, /*syn*/ T, /*etb*/ T,
%%    /*can*/ T, /*em */ T, /*sub*/ T, /*esc*/ T, /*fs */ T, /*gs */ T, /*rs */ T, /*us */ T,
%%    /*sp */ T, /* ! */ T, /* " */ T, /* # */ T, /* $ */ T, /* % */ T, /* & */ T, /* ' */ T,
%%    /* ( */ T, /* ) */ F, /* * */ T, /* + */ T, /* , */ F, /* - */ T, /* . */ F, /* / */ T,
%%    /* 0 */ T, /* 1 */ T, /* 2 */ T, /* 3 */ T, /* 4 */ T, /* 5 */ T, /* 6 */ T, /* 7 */ T,
%%    /* 8 */ T, /* 9 */ T, /* : */ T, /* ; */ F, /* < */ T, /* = */ T, /* > */ T, /* ? */ T,
%%    /* @ */ T, /* A */ T, /* B */ T, /* C */ T, /* D */ T, /* E */ T, /* F */ T, /* G */ T,
%%    /* H */ T, /* I */ T, /* J */ T, /* K */ T, /* L */ T, /* M */ T, /* N */ T, /* O */ T,
%%    /* P */ T, /* Q */ T, /* R */ T, /* S */ T, /* T */ T, /* U */ T, /* V */ T, /* W */ T,
%%    /* X */ T, /* Y */ T, /* Z */ T, /* [ */ T, /* \ */ T, /* ] */ F, /* ^ */ T, /* _ */ T,
%%    /* ` */ T, /* a */ T, /* b */ T, /* c */ T, /* d */ T, /* e */ T, /* f */ T, /* g */ T,
%%    /* h */ T, /* i */ T, /* j */ T, /* k */ T, /* l */ T, /* m */ T, /* n */ T, /* o */ T,
%%    /* p */ T, /* q */ T, /* r */ T, /* s */ T, /* t */ T, /* u */ T, /* v */ T, /* w */ T,
%%    /* x */ T, /* y */ T, /* z */ T, /* { */ T, /* | */ T, /* } */ F, /* ~ */ T, /*del*/ T,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    %%/*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F)

const spaceAfterP : array chr (0) .. chr (255) of boolean := init (T,F)
%%    /*nul*/ T, /*soh*/ T, /*stx*/ T, /*etx*/ T, /*eot*/ T, /*enq*/ T, /*ack*/ T, /*bel*/ T,
%%    /*bs */ T, /*ht */ T, /*nl */ T, /*vt */ T, /*np */ T, /*cr */ T, /*so */ T, /*si */ T,
%%    /*dle*/ T, /*dc1*/ T, /*dc2*/ T, /*dc3*/ T, /*dc4*/ T, /*nak*/ T, /*syn*/ T, /*etb*/ T,
%%    /*can*/ T, /*em */ T, /*sub*/ T, /*esc*/ T, /*fs */ T, /*gs */ T, /*rs */ T, /*us */ T,
%%    /*sp */ T, /* ! */ T, /* " */ T, /* # */ T, /* $ */ T, /* % */ T, /* & */ T, /* ' */ T,
%%    /* ( */ F, /* ) */ T, /* * */ T, /* + */ T, /* , */ T, /* - */ T, /* . */ F, /* / */ T,
%%    /* 0 */ T, /* 1 */ T, /* 2 */ T, /* 3 */ T, /* 4 */ T, /* 5 */ T, /* 6 */ T, /* 7 */ T,
%%    /* 8 */ T, /* 9 */ T, /* : */ T, /* ; */ T, /* < */ T, /* = */ T, /* > */ T, /* ? */ T,
%%    /* @ */ T, /* A */ T, /* B */ T, /* C */ T, /* D */ T, /* E */ T, /* F */ T, /* G */ T,
%%    /* H */ T, /* I */ T, /* J */ T, /* K */ T, /* L */ T, /* M */ T, /* N */ T, /* O */ T,
%%    /* P */ T, /* Q */ T, /* R */ T, /* S */ T, /* T */ T, /* U */ T, /* V */ T, /* W */ T,
%%    /* X */ T, /* Y */ T, /* Z */ T, /* [ */ F, /* \ */ T, /* ] */ T, /* ^ */ T, /* _ */ F,
%%    /* ` */ T, /* a */ T, /* b */ T, /* c */ T, /* d */ T, /* e */ T, /* f */ T, /* g */ T,
%%    /* h */ T, /* i */ T, /* j */ T, /* k */ T, /* l */ T, /* m */ T, /* n */ T, /* o */ T,
%%    /* p */ T, /* q */ T, /* r */ T, /* s */ T, /* t */ T, /* u */ T, /* v */ T, /* w */ T,
%%    /* x */ T, /* y */ T, /* z */ T, /* { */ F, /* | */ T, /* } */ T, /* ~ */ T, /*del*/ T,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%% %%   /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%% %%   /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%% %%   /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%% %%   /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%% %%   /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%% %%   /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%% %%   /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%% %%   /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%% %%   /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%% %%   /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F,
%%    /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F, /*   */ F)


procedure printLeavesTraversal (subtreeNP : nodePT, trace : boolean)

    case nodes (subtreeNP).kind of
    
	label kindT.order, kindT.choose :
	    % just print out the kids
	    var subtreeKidsCP := nodes (subtreeNP).kidsCP
	    loop
		exit when subtreeKidsCP = nilCell
		printLeavesTraversal (cells (subtreeKidsCP).firstNP, trace)
		subtreeKidsCP := cells (subtreeKidsCP).restCP
	    end loop

	label kindT.empty :
	    % might be a paragraphing symbol!
	    const name := nodes (subtreeNP).name

	    if name = NL_T then
		if not blankLine then
		    if trace then
			put : 0, ""
		    else
			put ""
		    end if
		    blankLine := emptyLine
		    emptyLine := true
		    lineLength := 0
		end if
	    elsif name = IN_T then
		if indent < maxIndent then
		    indent += indentIncrement
		end if
	    elsif name = EX_T then
		if indent > 0 then
		    indent -= indentIncrement
		end if
	    elsif name = SP_T then
		if not blankLine then
		    if trace then
			put : 0, " " ..
		    else
			put " " ..
		    end if
		end if
	    elsif name = SPOFF_T then
		spacing := false
	    elsif name = SPON_T then
		spacing := true
	    end if

        label :
	    % it's a leaf - print it out
	    const leafName := identTable (nodes (subtreeNP).name)
	    const lengthLeaf := length (leafName)
	    const leafName1 : char := leafName (1)

	    if trace then
		if emptyLine then
		    put : 0, repeat (" ", indent) ..
		    emptyLine := false
		    lineLength := indent
		elsif (not raw_p) and lineLength + 1 + lengthLeaf > maxOutputLineLength then
		    put : 0, ""
		    put : 0, repeat (" ", indent + tempIndent) ..
		    emptyLine := false
		    lineLength := indent + tempIndent
		elsif spacing and (not raw_p) and spaceAfterP (lastLeafNameEnd) and 
			spaceBeforeP (leafName1) then
		    put : 0, " " ..
		    lineLength += 1
		elsif spacing and raw_p and idCharP (lastLeafNameEnd) and 
			idCharP (leafName1) then
		    put : 0, " " ..
		    lineLength += 1
		end if
		put : 0, leafName ..
		lineLength += lengthLeaf
	    else
		if emptyLine then
		    put repeat (" ", indent) ..
		    emptyLine := false
		    lineLength := indent
		elsif (not raw_p) and lineLength + 1 + lengthLeaf > maxOutputLineLength then
		    put ""
		    put repeat (" ", indent + tempIndent) ..
		    emptyLine := false
		    lineLength := indent + tempIndent
		elsif spacing and (not raw_p) and spaceAfterP (lastLeafNameEnd) and 
			spaceBeforeP (leafName1) then
		    put " " ..
		    lineLength += 1
		elsif spacing and raw_p and idCharP (lastLeafNameEnd) and 
			idCharP (leafName1) then
		    put " " ..
		    lineLength += 1
		end if
		put leafName ..
		lineLength += lengthLeaf
	    end if

	    blankLine := false
	    lastLeafNameEnd := leafName (*)
    end case

end printLeavesTraversal


procedure printLeaves (subtreeNP : nodePT, trace : boolean)
    indent := 0
    emptyLine := true
    blankLine := true
    spacing := true
    printLeavesTraversal (subtreeNP, trace)
end printLeaves 


procedure printSource (finalTreeNP : nodePT)
    printLeaves (finalTreeNP, false)
    put ""
end printSource


procedure printLocalVars (localVars : localsListT)
    for v : 1 .. localVars.nlocals
        put : 0, identTable (localVars.local (v).name),
            " [", identTable (localVars.local (v).typename), "] = '" ..
        if localVars.local (v).valueNP not= nilNode then
            printLeaves (localVars.local (v).valueNP, true)
        end if
        put : 0, "'"
    end for
end printLocalVars
include "syntaxerror.i"
% TXL v5.3 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% Syntax error handling

procedure syntaxError (failTokenHandle : inputTokenHT)
    % give source coordinates
    if failTokenHandle >= lastTokenHandle then
	error ("Syntax error at end of " + fileNames (1) + ", near:", WARNING)
    else
	error ("Syntax error near line " + 
	    intstr (inputTokenLineNum (failTokenHandle) mod maxLines, 1) + 
	    " of " + fileNames (inputTokenLineNum (failTokenHandle) div maxLines) + 
	    ", at or near:", WARNING)
    end if

    put : 0, "\t" ..

    % find the ten (or fewer) tokens around the failure
    const startTokenHandle := max (1, failTokenHandle - 5)
    const endTokenHandle := min (failTokenHandle + 5, lastTokenHandle - 1)

    % now show them
    if startTokenHandle > endTokenHandle then
    	    put : 0, "EOF" ..
    else	    
    	for handle : startTokenHandle .. endTokenHandle
	    if handle = failTokenHandle then
		put : 0, ">>> ",
		identTable (inputTokens (handle)), " <<< " ..
	    else
		put : 0, identTable (inputTokens (handle)), " " ..
	    end if
	end for
    end if
    put : 0, ""
    quit 
end syntaxError


function externalType (internalType : string) : string
    if index (internalType, "list_1_") = 1 then
	result "list " + internalType (8..*) + "+"
    elsif index (internalType, "list__") = 1 then
	result "list " + internalType (7..*) 
    elsif index (internalType, "repeat_1_") = 1 then
	result "repeat " + internalType (10..*) + "+"
    elsif index (internalType, "repeat__") = 1 then
	result "repeat " + internalType (9..*) 
    elsif index (internalType, "opt__") = 1 then
	const targetType := internalType (6..*)
	if index (targetType, "lit_") = 1 then
	    result "opt '" + targetType (5..*) 
	else
	    result "opt " + targetType
	end if
    else
	result internalType
    end if
end externalType


procedure printSkippedToken (litsAndVarsAndExpsNP : nodePT)
    var firstsKidNP := trees.kid1NP (trees.plural_firstNP (litsAndVarsAndExpsNP))
    put : 0, "\t" ..

    if identTable (nodes (firstsKidNP).name) = "TXL_literal_" then
	put : 0, identTable (trees.literal_tokenT (firstsKidNP))

    elsif identTable (nodes (firstsKidNP).name) = "TXL_firstTime_" then
	put : 0, identTable (trees.firstTime_nameT (firstsKidNP)), " [",
	    externalType (identTable (trees.firstTime_typeT (firstsKidNP))), "]"

    elsif identTable (nodes (firstsKidNP).name) = "TXL_expression_" then
	put : 0, identTable (trees.expression_baseT (firstsKidNP)), " " ..
	var ruleCallsNP := trees.expression_ruleCallsNP (firstsKidNP)
	var ruleCallNP, literalsNP : nodePT

	loop
	    exit when trees.plural_emptyP (ruleCallsNP)
	    ruleCallNP := trees.plural_firstNP (ruleCallsNP)
	    put : 0, "[", identTable (trees.ruleCall_nameT (ruleCallNP)) ..
	    literalsNP := trees.ruleCall_literalsNP (ruleCallNP)

	    loop
		exit when trees.plural_emptyP (literalsNP)
		%put : 0, " ", identTable (trees.literal_tokenT (trees.kid1NP (literalsNP))) ..
		put : 0, " ", identTable (trees.literal_tokenT (trees.plural_firstNP 
		    (literalsNP))) ..
		literalsNP := trees.plural_restNP (literalsNP)
	    end loop

	    put : 0, "]" ..
	    ruleCallsNP := trees.plural_restNP (ruleCallsNP)
	end loop
	put : 0, ""

    else
	error ("(TXL internal error) Fatal TXL internal error in prinSkippedToken", FATAL)
    end if

end printSkippedToken


procedure patternError (litsAndVarsAndExpsNP : nodePT, where : string)
    error ("Syntax error in the " + where + ", at or near:", WARNING)

    if trees.plural_emptyP (litsAndVarsAndExpsNP) then
	put : 0, "EOF"
    else
	printSkippedToken (litsAndVarsAndExpsNP)
    end if

    quit 
end patternError

% Phases of the TXL processor
%#if not NOCOMPILE then
    %child "bootstrap.ch"
% TXL v5.3 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% Bootstrap of Parser for the TXL Source Language itself

%parent "txl.t"

stub module bootstrap
    import (var cells, cellPT, var nodes, nodePT, newNode, newCell,
        var keywordTokens, var nKeys, sortKeys, tokenT, kindT, maxBootstrapSymbols, 
	tokenValueT, var ident, identTable, idCharP, separatorP, var trees,
	error)

    export (makeGrammarTree)

    procedure makeGrammarTree (bootFileName : string, var grammarTreeNP : nodePT)

end bootstrap


body module bootstrap

    var bootFile : int
    var lookahead : char
    var nextToken : string

    var bootSymbolTable : array 1 .. maxBootstrapSymbols of nodePT
    var bootSymbolTableSize := 0


    procedure enterBootSymbol (partId : tokenT, var symbolIndex : int)
	for p : 1 .. bootSymbolTableSize
	    if nodes (bootSymbolTable (p)).name = partId then
		symbolIndex := p
		return
	    end if
	end for

	if bootSymbolTableSize = maxBootstrapSymbols then
	    error ("(TXL internal error) Too many symbols in TXL bootstrap specification", FATAL)
	end if

	bootSymbolTableSize += 1
	symbolIndex := bootSymbolTableSize
	newNode (bootSymbolTable (symbolIndex)) 
	bind var register newsym to nodes (bootSymbolTable (symbolIndex))
	newsym.name := partId
	newsym.kind := kindT.undefined % default
	newsym.kidsCP := nilCell
	newsym.count := 0
    end enterBootSymbol


    procedure getNextToken (expectedToken : string)
        loop
            exit when lookahead not= '%' and not separatorP (lookahead)
            if lookahead = '%' then
                var comment : string
                get : bootFile, comment : *
            end if
            get : bootFile, lookahead 
        end loop

	const firstchar := lookahead
        nextToken := lookahead
        get : bootFile, lookahead 

        if idCharP (firstchar) then
            loop
                exit when lookahead = '\0' or not idCharP (lookahead)
                nextToken += lookahead
                get : bootFile, lookahead 
            end loop
        end if

        if expectedToken not= "" and nextToken not= expectedToken then
	    error ("(TXL internal error) Syntax error in TXL bootstrap specification\n" +
            	"  (expected " + expectedToken + " + got " + nextToken + ")", 
		FATAL)
        end if
    end getNextToken


    procedure processDefineBody (parentIndex : int)

	% it's an order node until we see otherwise
	nodes (bootSymbolTable (parentIndex)).kind := kindT.order

	% allocate first kid cell 
	var kidCount := 0
	var kidListCP : cellPT
	newCell (kidListCP)
	nodes (bootSymbolTable (parentIndex)).kidsCP := kidListCP

        getNextToken ("")

	loop
	    var identIndex : tokenT
	    var kidNP : nodePT

	    if nextToken = "[" then
		% non-terminal or builtin
		getNextToken ("")
		ident.install (nextToken, identIndex)
		var kidIndex : int
		enterBootSymbol (identIndex, kidIndex)
		kidNP := bootSymbolTable (kidIndex)
		getNextToken ("]")

	    else
		% literal
		if nextToken = "'" then
		    % quoted literal
		    getNextToken ("")
		end if
		ident.install (nextToken, identIndex)
		newNode (kidNP)
		bind var register kid to nodes (kidNP) 
		kid.kind := kindT.literal
		kid.name := identIndex
		kid.kidsCP := nilCell
		kid.count := 0
	    end if

	    kidCount += 1
	    assert kidCount < maxKids

	    cells (kidListCP).firstNP := kidNP
	    cells (kidListCP).restCP := nilCell

	    getNextToken ("")

	    exit when nextToken = "end"

	    if nodes (bootSymbolTable (parentIndex)).kind = kindT.choose then
		if nextToken = "|" then
		    getNextToken ("")
		else
		    error ("(TXL internal error) Syntax error in TXL bootstrap specification\n" +
			"  (expected '|', got '" + nextToken + "')", FATAL)
		end if
	    elsif nextToken = "|" then
		if kidCount = 1 then
		    nodes (bootSymbolTable (parentIndex)).kind := kindT.choose
		    getNextToken ("")
		else
		    error ("(TXL internal error) Syntax error in TXL bootstrap specification\n" +
			"  (multiple tokens in choice alternative)", FATAL)
		end if
	    end if

	    % allocate next kid cell
	    newCell (cells (kidListCP).restCP)
	    kidListCP := cells (kidListCP).restCP
	end loop

	% These necessary conditions for high-falutin' parser optimizations!
	nodes (bootSymbolTable (parentIndex)).count := kidCount
	assert trees.contiguousKids (bootSymbolTable (parentIndex))

    end processDefineBody


    procedure processDefine
        var symbolIndex : int
        var identIndex : tokenT

        getNextToken ("define")

        % get name of production
        getNextToken ("")
        ident.install (nextToken, identIndex)
        enterBootSymbol (identIndex, symbolIndex)

        % now process the body - in the TXL bootstrap it can only be one 
	% of two simple forms:
        %     "order", a sequence of single terminals and nonterminals,     
	%	        e.g., A [B] C [D] E, 
	%  or "choose", a choice between single terminals and nonterminals,
	%		e.g., A | [B] | C | [D] | E

	processDefineBody (symbolIndex)

	assert nextToken = "end"
	getNextToken ("define")

    end processDefine


    procedure setUpBuiltins
        var symbolIndex : int
        var identIndex : tokenT

	ident.install ("stringlit", identIndex)
	enterBootSymbol (identIndex, symbolIndex)
	nodes (bootSymbolTable (symbolIndex)).kind := kindT.stringlit

	ident.install ("charlit", identIndex)
	enterBootSymbol (identIndex, symbolIndex)
	nodes (bootSymbolTable (symbolIndex)).kind := kindT.charlit

	ident.install ("number", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.number

	ident.install ("floatnumber", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.floatnumber

	ident.install ("decimalnumber", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.decimalnumber

	ident.install ("integernumber", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.integernumber

        ident.install ("id", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.id

        ident.install ("upperlowerid", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.upperlowerid

        ident.install ("upperid", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.upperid

        ident.install ("lowerupperid", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.lowerupperid

        ident.install ("lowerid", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.lowerid

        ident.install ("token", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.token

        ident.install ("key", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.key

	ident.install ("empty", identIndex)
	enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.empty

	% for historical reasons, retain old emptyString
	ident.install ("emptyString", identIndex)
	enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.empty

	% new output paragraphing symbols
        ident.install ("NL", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.empty

        ident.install ("IN", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.empty

        ident.install ("EX", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.empty

        ident.install ("SP", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.empty

        ident.install ("SPOFF", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.empty

        ident.install ("SPON", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        nodes (bootSymbolTable (symbolIndex)).kind := kindT.empty
    end setUpBuiltins


    body procedure makeGrammarTree % (bootFileName : string,
        %	 var grammarTreeNP : nodePT)

        var symbolIndex : int
        var identIndex : tokenT

        % TXL grammar tree root
        ident.install ("program", identIndex)
        enterBootSymbol (identIndex, symbolIndex)
        grammarTreeNP := bootSymbolTable (symbolIndex)

        open : bootFile, bootFileName, get
        get : bootFile, lookahead 

	% Install the TXL built-in symbols
	setUpBuiltins

        % TXL keyword list 
        getNextToken ("keys")
        nKeys := 0
        loop
            getNextToken ("")
            exit when nextToken = "end"
            nKeys += 1
            if nextToken = "'" then
                % keywords may be quoted
		getNextToken ("")
            end if
	    ident.install (nextToken, keywordTokens (nKeys))
        end loop
        getNextToken ("keys")

	sortKeys

        % TXL grammar defines 
        loop
	    get : bootFile, skip
            exit when eof (bootFile)
            processDefine
        end loop

        % There better not be any rules in the TXL bootstrap grammar, though!
        assert eof (bootFile)

        close : bootFile

        % Check that there are no undefined symbols
        var errorcount := 0

        for i : 1 .. bootSymbolTableSize
            if nodes (bootSymbolTable (i)).kind = kindT.undefined then
		error ("(TXL internal error) In TXL bootstrap specification, symbol '" +
		    identTable (nodes (bootSymbolTable (i)).name) +
                    "' has not been defined", WARNING)
                errorcount += 1
            end if
        end for

        if errorcount not= 0 then
            quit
        end if

    end makeGrammarTree

end bootstrap
%#end if
%child "scan.ch"
% TXL v6.0 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

%parent "txl.t"

stub module scanner
    import (separatorP, letterP, idCharP, digitP, keyP,
        var ident, var inputTokens, var inputTokenKind, var inputTokenLineNum,
	var fileNames, var nFiles, var compoundTokens, var nCompounds, 
	var commentTokens, var nComments, txl_p, no_comment_p,
	sortCompounds, error)

    export (tokenize)

    procedure tokenize (sourceFileName : string,
	var firstTokenH: inputTokenHT,
	var lastTokenH : inputTokenHT, isTxlSource : boolean)
end scanner

body module scanner
    % current input file
    var inputStream : int := 0

    % primitive include facility
    var includeStack : array 1 .. maxIncludeDepth of 
	record
	    file : int
	    filenum : 0 .. maxFiles
	    linenum : 0 .. maxLines
	end record
    var includeDepth := 0

    % directory context for includes
    var sourceFileDirectory := ""

    % lookahead
    % this length is necessary for some type cheats we use for speed
    % it must be at least 2 * Turing's maxStringLength
    var inputline : char (512)
    var inputchar : int
    for i : 1 .. 512
	inputline (i) := '\0'
    end for

    % current file number
    var filenum : 0 .. maxFiles

    % current line number
    var linenum : 0 .. maxLines

    % kind of source file
    var txlSource : boolean


    const EOF := chr (254)

    procedure getInputLine
	if eof (inputStream) then
	    inputline (1) := EOF
	else
	    get : inputStream, type (string, inputline) : *
	    linenum += 1
	end if
	inputchar := 1
    end getInputLine


    procedure PushInclude
	% get new include file name, and be sure we align on a line boundary
	var newFileName := type (string, inputline (inputchar))

 	if index (newFileName, "\"") not= 0 then
	    newFileName := newFileName (index (newFileName, "\"")+1..*)
	end if

 	if index (newFileName, "\"") not= 0 then
	    newFileName := newFileName (1..index (newFileName, "\"")-1)
	end if

	% remember what directory we started in!
	newFileName := sourceFileDirectory + newFileName

	% open it
	if nFiles = maxFiles then
	    error ("Too many source include files (>" + intstr (maxFiles, 1) + ")", FATAL)
	end if

	var newInputStream : int
	open : newInputStream, newFileName, get
	if newInputStream = 0 then
	    error ("Unable to open include file '" + newFileName + "'", FATAL)
	end if

	% push old source file to include stack
	if includeDepth = maxIncludeDepth then
	    error ("Include file nesting too deep (>" + intstr (maxIncludeDepth, 1) + ")", FATAL)
	end if

	includeDepth += 1
	bind var is to includeStack (includeDepth) 
	is.file := inputStream
	is.filenum := filenum
	is.linenum := linenum

	nFiles += 1
	fileNames (nFiles) := newFileName

	filenum := nFiles
	inputStream := newInputStream

	linenum := 0
	getInputLine
    end PushInclude

    procedure PopInclude
	pre includeDepth > 0
	close : inputStream

	bind is to includeStack (includeDepth) 
	inputStream := is.file 
	filenum := is.filenum 
	linenum := is.linenum

	includeDepth -= 1

	type (string, inputline) := ""
    end PopInclude

    procedure openFile (fileName : string)
        pre inputStream = 0
        open : inputStream, fileName, get

	if inputStream = 0 then
	    error ("Unable to open source file '" + fileName + "'", FATAL)
	end if

	nFiles := 1
	fileNames (1) := fileName

	if index (fileName, "/") not= 0 or index (fileName, ":") not= 0 then
	    sourceFileDirectory := fileName
	    loop
		exit when sourceFileDirectory (*) = "/" or
		    sourceFileDirectory (*) = ":"
		sourceFileDirectory := sourceFileDirectory (1 .. *-1)
	    end loop
	end if

	filenum := 1
	linenum := 0
        getInputLine
    end openFile

    procedure closeFile
        pre inputStream ~= 0
        close : inputStream
        inputStream := 0
    end closeFile

    procedure skipTxlComment
        pre inputline (inputchar) = '%'
	getInputLine
    end skipTxlComment

    procedure skipNonTxlComment (commentIndex : int)
	pre inputline (inputchar) = commentTokens (commentIndex) (1)
	type (string, inputline) := 
	    type (string, inputline) (inputchar + length (commentTokens (commentIndex)) .. *)
	const commentEnd : compoundT := commentTokens (commentIndex+1)
	if commentEnd = "" then
	    getInputLine
	else
	    loop
		inputchar := index (type (string, inputline), commentEnd) 
		exit when inputchar not= 0
		getInputLine
		if inputline (1) = EOF then
		    error ("Syntax error near line " + intstr (linenum,1) +
			" of " + fileNames (filenum) + 
			" : \n  comment ends at end of file", FATAL)
		end if
	    end loop
	    assert inputchar not= 0
	    inputchar += length (commentEnd)
	end if
    end skipNonTxlComment

    procedure skipSeparators
        loop
	    if inputline (inputchar) = '\0' then
		getInputLine
		exit when inputline (inputchar) = EOF
            elsif separatorP (inputline (inputchar)) then
		inputchar += 1
	    elsif txlSource then
		if inputline (inputchar) = '%' then
		    skipTxlComment
		else
		    return
		end if
	    elsif not no_comment_p then
		assert not txlSource
		var c := 1
		loop
		    exit when c > nComments
		    bind ct to commentTokens (c)
		    if inputline (inputchar) = ct (1) then
			const ctlength := length (ct)
			if length (type (string, inputline (inputchar))) >= ctlength 
				and type (string, inputline (inputchar)) (1 .. ctlength) 
				    = ct then
			    exit
			end if
		    end if
		    c += 2
		end loop
		exit when c > nComments
		skipNonTxlComment (c)
	    end if
        end loop
    end skipSeparators

    procedure getId (var nextId : tokenValueT)
        pre letterP (inputline (inputchar))
	const startchar := inputchar
        loop
            inputchar += 1
            exit when not idCharP (inputline (inputchar))
        end loop

	if inputchar - startchar > maxCharsPerToken then
	    error ("Syntax error near line " + intstr (linenum,1) +
		" of " + fileNames (filenum) + 
		" : \n  identifier too long", FATAL)
	end if

	nextId := type (string, inputline) (startchar .. inputchar-1)
    end getId

    procedure takeDigits 
        loop
            exit when not digitP (inputline (inputchar))
	    inputchar += 1
	end loop
    end takeDigits

    procedure getNumber (var nextNumber : tokenValueT)
        pre digitP (inputline (inputchar))
	const startchar := inputchar

        if nextNumber not= '.' then
            takeDigits 
        end if

        if inputline (inputchar) = '.' and digitP (inputline (inputchar+1)) then
	    inputchar += 2
            takeDigits 
        end if

        if (inputline (inputchar) = 'e' or inputline (inputchar) = 'E') 
		and (inputline (inputchar+1) = '+' or inputline (inputchar+1) = '-'
			or digitP (inputline (inputchar+1)) ) then
	    inputchar += 2
	    takeDigits
        end if

	if inputchar - startchar > maxCharsPerToken then
	    error ("Syntax error near line " + intstr (linenum,1) +
		" of " + fileNames (filenum) + 
		" : \n  number literal too long", FATAL)
	end if

	nextNumber := type (string, inputline) (startchar .. inputchar-1)
    end getNumber

    procedure getString (var nextString : tokenValueT, quote : char)
        pre inputline (inputchar) = quote
	const startchar := inputchar
	loop
	    inputchar += 1
	    if inputline (inputchar) = '\\' then
		inputchar += 2
	    end if
            exit when inputline (inputchar) = quote or inputline (inputchar) = '\0'
        end loop

	if inputline (inputchar) not= quote 
		or inputchar - startchar + 1 > maxCharsPerToken then
	    error ("Syntax error near line " + intstr (linenum,1) +
		" of " + fileNames (filenum) + 
		" :\n  string or char literal too long or missing ending quote", FATAL)
	end if

        nextString := type (string, inputline) (startchar .. inputchar) 
        inputchar += 1
    end getString


    procedure ProcessCompounds
        loop
	    skipSeparators
	    if inputline (inputchar) = '\'' then
		inputchar += 1
	    end if
	    exit when inputline (inputchar) = EOF or inputline (inputchar) = 'e'
	    if nCompounds = maxCompoundTokens then
		error ("Too many compound token definitions (>" + 
		    intstr (maxCompoundTokens, 1) + ")", FATAL)
	    end if
	    nCompounds += 1
	    const startchar := inputchar
	    loop
		inputchar += 1
		exit when inputline (inputchar) = '\0' or separatorP (inputline (inputchar))
		exit when inputchar - startchar = maxCompoundLength
	    end loop
	    if inputchar - startchar = 1 or
		    (inputline (inputchar) not= '\0' and not separatorP (inputline (inputchar))) then
		error ("Compound token too short or too long (<2 or >" 
		    + intstr (maxCompoundLength,1) + " chars)", FATAL)
	    end if
	    compoundTokens (nCompounds) := 
		type (string, inputline) (startchar ..  inputchar-1)
	end loop
	var endid, compoundsid : tokenValueT := ""
	if inputline (inputchar) = 'e' then
	    getId (endid)
	    skipSeparators
	    if letterP (inputline (inputchar)) then
		getId (compoundsid)
	    end if
	end if
	if endid not= "end" or compoundsid not="compounds" then
	    error ("Syntax error at '" + endid + " " + compoundsid +
		"', 'end compounds' expected", FATAL)
	end if

	sortCompounds
    end ProcessCompounds


    procedure ProcessCommentBrackets
	nComments := 0
        loop
	    skipSeparators
	    if inputline (inputchar) = '\'' then
		inputchar += 1
	    end if
	    exit when inputline (inputchar) = EOF or inputline (inputchar) = 'e'
	    if nComments = maxCommentTokens then
		error ("Too many comment bracket definitions (>" + 
		    intstr (maxCommentTokens, 1) + ")", FATAL)
	    end if
	    nComments += 1
	    const startchar := inputchar
	    loop
		inputchar += 1
		exit when inputline (inputchar) = '\0' or separatorP (inputline (inputchar))
		exit when inputchar - startchar = maxCompoundLength
	    end loop
	    if inputline (inputchar) not= '\0' and not separatorP (inputline (inputchar)) then
		error ("Comment bracket too long (>" 
		    + intstr (maxCompoundLength,1) + " chars)", FATAL)
	    end if
	    commentTokens (nComments) := 
		type (string, inputline) (startchar ..  inputchar-1)

	    % second bracket is optional
	    loop
		exit when inputline (inputchar) = '\0' 
		    or not separatorP (inputline (inputchar))
		inputchar += 1
	    end loop
	    nComments += 1
	    if inputline (inputchar) = '\0' then
		commentTokens (nComments) := ""
	    else
		const startchar2 := inputchar
		loop
		    inputchar += 1
		    exit when inputline (inputchar) = '\0' or separatorP (inputline (inputchar))
		    exit when inputchar - startchar2 = maxCompoundLength
		end loop
		if inputline (inputchar) not= '\0' and not separatorP (inputline (inputchar)) then
		    error ("Comment bracket too long (>" 
			+ intstr (maxCompoundLength,1) + " chars)", FATAL)
		end if
		commentTokens (nComments) := 
		    type (string, inputline) (startchar2 ..  inputchar-1)
	    end if
	end loop
	var endid, commentsid : tokenValueT := ""
	if inputline (inputchar) = 'e' then
	    getId (endid)
	    skipSeparators
	    if letterP (inputline (inputchar)) then
		getId (commentsid)
	    end if
	end if
	if endid not= "end" or commentsid not="comments" then
	    error ("Syntax error at '" + endid + " " + commentsid +
		"', 'end comments' expected", FATAL)
	end if
    end ProcessCommentBrackets

    procedure checkForCompoundToken (var baseToken : tokenValueT)
	const baseChar : char := baseToken (1)
	const baseText := type (string, inputline (inputchar-1)) 
	const baseLength := length (baseText)
	for c : 1 .. nCompounds
	    bind ct to compoundTokens (c)

	    % compounds are sorted in reverse order!
	    exit when ct (1) < baseChar

	    const ctlength := length (ct)
	    if baseChar = ct (1) and baseLength >=  ctlength
		    and baseText (1 .. ctlength) = ct then
		inputchar += ctlength - 1
		baseToken := ct
		return
	    end if
	end for
    end checkForCompoundToken

    procedure getToken (var nextToken : tokenValueT, var nextTokenKind : kindT)

	skipSeparators % including eol comments

	if inputline (inputchar) = EOF then
	    nextToken := ""
	    nextTokenKind := kindT.undefined
	elsif letterP (inputline (inputchar)) then
	    getId (nextToken)
	    nextTokenKind := kindT.id
	elsif digitP (inputline (inputchar)) then
	    getNumber (nextToken)
	    nextTokenKind := kindT.number
	elsif inputline (inputchar) = '"' then
	    getString (nextToken, '"')
	    nextTokenKind := kindT.stringlit
	elsif inputline (inputchar) = '\'' and not (txlSource or txl_p) then
	    getString (nextToken, '\'')
	    nextTokenKind := kindT.charlit
	elsif inputline (inputchar) = '\'' and inputline (inputchar+1) = '\'' then
	    inputchar += 1
	    getString (nextToken, '\'')
	    nextTokenKind := kindT.charlit
	else
	    if inputline (inputchar) = '\'' and inputline (inputchar+1) = '%' then
		inputchar += 1
	    end if

	    nextToken := inputline (inputchar)
	    inputchar += 1

	    if nCompounds > 0 then
		checkForCompoundToken (nextToken)
	    end if

	    nextTokenKind := kindT.literal
	end if
    end getToken

    body procedure tokenize % (sourceFileName : string,
	% var firstTokenH, lastTokenH : inputTokenHT, isTxlSource : boolean)

	openFile (sourceFileName)

	txlSource := isTxlSource

	filenum := 1
	linenum := 0

	firstTokenH := 1
	lastTokenH := 0
	
	var token : tokenValueT := ""
	var tokenKind : kindT
	loop
	    const previousToken := token
	    loop
		getToken (token, tokenKind)

		exit when not txlSource or previousToken = "'"

		exit when token not= "include" and token not= "compounds" 
		    and token not= "comments" and token not= ""

		if token = "include" then
		    PushInclude
		elsif token = "compounds" then
		    ProcessCompounds
		elsif token = "comments" then
		    ProcessCommentBrackets
		else
		    exit when includeDepth = 0
		    PopInclude
		end if
	    end loop

	    exit when token = ""

	    lastTokenH += 1

	    if lastTokenH > maxTokens then
		error ("Source file '" + sourceFileName + "' too big (> " +
		    intstr (maxTokens, 1) + " tokens)", FATAL)
	    end if

	    ident.install (token, inputTokens (lastTokenH))

	    if keyP (inputTokens (lastTokenH)) then
		tokenKind := kindT.key
	    end if

	    inputTokenKind (lastTokenH) := tokenKind
	    inputTokenLineNum (lastTokenH) := filenum * maxLines + linenum

	    if inputTokens (lastTokenH) = NO_ROOM then
		error ("Source file '" + sourceFileName + "' too big or complex (> " +
		    intstr (identTableSize, 1) + " unique tokens)", FATAL)
	    end if
	end loop

	lastTokenH += 1

	if lastTokenH > maxTokens then
	    error ("Source file '" + sourceFileName + "' too big (> " +
		intstr (maxTokens, 1) + " tokens)", FATAL)
	end if

	inputTokens (lastTokenH) := emptyT
	inputTokenKind (lastTokenH) := kindT.empty

	closeFile
    end tokenize

end scanner
%child "parse.ch"
% TXL v5.3 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

%parent "txl.t"

stub module parser
    import (var nodes, var cells, newNode, newCell, var nodeCount, var cellCount,
	var depthTokenAccepted, var tokenHandle, var failTokenHandle, 
	lastTokenHandle, var ident, identTable, inputTokens, inputTokenKind,
        keyP, letterP, lowerP, upperP, digitP, node_print_p, printParse, var trees, error)

    export (parse)

    procedure parse (patternNP : nodePT, var parseNP : nodePT, var fail : boolean)
end parser

body module parser

    % Parse stack for detecting inifinite parses
    const * parseTooDeep := 961

    var parseDepth := - 1
    var parseStack : array 0 .. maxParseDepth of tokenT


    module parseScan
        import (var tokenHandle, parseDepth, tokenT, inputTokens, inputTokenKind,
            var depthTokenAccepted, lastTokenHandle, var failTokenHandle)

        export (accept, backup, nextToken, nextTokenKind, depthOfLastAccept)

        % The purpose of this module is to provide a clean interface to
        % the scanner, that is consistent with compile_rules.ch
        %
        % parseScan provides the following routines
        %
        % accept 		advances the input one token
        % backup 		backs the input up one token
        % nextToken	 	returns the next (current) token
        % depthOfLastAccept 	returns the parse depth when the token before
        %			    the current one was accepted

        procedure accept
            depthTokenAccepted (tokenHandle) := parseDepth
            tokenHandle += 1
            if tokenHandle > failTokenHandle then
                failTokenHandle := tokenHandle
            end if
        end accept

        procedure backup
            tokenHandle -= 1
        end backup

        function depthOfLastAccept : int
            result depthTokenAccepted (tokenHandle - 1)
        end depthOfLastAccept

        function nextToken : tokenT
            result inputTokens (tokenHandle)
        end nextToken

        function nextTokenKind : kindT
            result inputTokenKind (tokenHandle)
        end nextTokenKind

    end parseScan


    procedure real_parse (patternNParg : nodePT, var parseNParg : nodePT)

	%
        % INPUT:
        %    patternNP - 	the target production
        %    parseNP -		either 1) nil, or
        %		       	       2) a previous parse yeilding the target
	%
        % OUTPUT:
        %    parseNP -  	either 1) a parse yeilding the target production, or
	%			       2) nil
	%
	% If input parseNP is nil, then output parseNP is the first possible parse.
	% If input parseNP is a previous parse, the output parseNP is the next possible parse.
	% In either case, if the parse is not possible then output parseNP will be nil.
        %


	bind register patternNP to patternNParg
	bind var register parseNP to parseNParg


	parseDepth += 1

	if parseNP = nilNode then

	    % First attempt - not a retry

	    if node_print_p then
		put : 0, repeat (".", parseDepth), "?", identTable (nodes (patternNP).name) ..
		if parseScan.nextToken = emptyT then
		    put : 0, " EOF"
		else
		    put : 0, " ", identTable (parseScan.nextToken)
		end if
	    end if


	    case nodes (patternNP).kind of

		label kindT.empty :

		    % empty - first time we just match it.
		    parseNP := patternNP


		label kindT.order :

		    % update parse stack (for choose and order nodes only!)
		    if parseDepth >= maxParseDepth then
			error ("(Fatal) Maximum parse depth exceeded", WARNING)
			quit : parseTooDeep
		    end if

		    parseStack (parseDepth) := nodes (patternNP).name

		    % Check for infinite parse loop
		    if (parseDepth - parseScan.depthOfLastAccept) > maxBlindParseDepth then
			% we're deep - better check for an infinite loop!
			for pd : parseScan.depthOfLastAccept + 1 .. parseDepth - 1
			    if parseStack (pd) = nodes (patternNP).name then
				% the never-ending story ...
				if node_print_p then 
				    put:0, "TXL Info: Gave up on infinite parse loop on '",
					identTable (nodes (patternNP).name),
					"' with lookahead '", identTable (parseScan.nextToken), "'"
				end if

				parseNP := nilNode
				parseDepth -= 1
				return
			    end if
			end for
		    end if

		    % required for fancy parser speedup!
		    assert trees.contiguousKids (patternNP)

		    const productionKids := nodes (patternNP).count
		    assert productionKids > 0 

		    % recover wasted space if we fail
		    const oldCellCount := cellCount
		    const oldNodeCount := nodeCount

		    % this is the sneakiest optimization in history!
		    % we pre-allocate ourselves a chunk of the cells array
		    % and use it directly to avoid a local dynamic array here,
		    % then link it up later if we succeed, otherwise free it.
		    if cellCount + productionKids > maxCells then
			error ("(Fatal) Out of cell space - " +
			    intstr (maxCells, 1) + " cells have been allocated.", WARNING)
			quit : outOfCells
		    end if

		    % don't try this at home, kids!
		    const baseParseKidCP := cellCount
		    cellCount += productionKids

		    % Now we parse!
		    % since they are contiguous, we can just run up and down
		    % the production kid list directly!
		    const baseProductionKidCP := nodes (patternNP).kidsCP - 1
		    % so parse knows it's the first try
		    cells (baseParseKidCP + 1).firstNP := nilNode  

		    var kid := 1
		    var retry := false
		    loop
			const oldTokenHandle := tokenHandle

			real_parse (cells (baseProductionKidCP + kid).firstNP, 
				    cells (baseParseKidCP + kid).firstNP)

			if cells (baseParseKidCP + kid).firstNP = nilNode then
			    % retry another match of the previous kid
			    kid -= 1
			    exit when kid = 0
			    retry := true
			elsif retry => oldTokenHandle not= tokenHandle then
			    % go on to the next one
			    kid += 1
			    exit when kid = productionKids + 1
			    retry := false
			    cells (baseParseKidCP + kid).firstNP := nilNode  % first try
			% else
			    % re-parses of an embedded kid that yield the 
			    % same lookahead are uninteresting since the 
			    % rest will fail in the same way!
			    %  - so ask for another try of the same kid
			end if
		    end loop

		    % we fail if we're at the left, 
		    % succeed if we made it all the way to the right.
		    % of course, now we need to build the tree if we succeeded.
		    if kid not= 0 then
			% build the parent
			newNode (parseNP)
			nodes (parseNP) := nodes (patternNP) % sets kind, name and nKids

			% link in the kids we already sneakily allocated 
			% and filled in directly back there
			nodes (parseNP).kidsCP := baseParseKidCP + 1

			for k : 1 .. productionKids - 1
			    const parseKidCP := baseParseKidCP + k
			    cells (parseKidCP).restCP := parseKidCP + 1
			end for

			cells (baseParseKidCP + productionKids).restCP := nilCell

		    else
			parseNP := nilNode
			% recover wasted space
			nodeCount := oldNodeCount
			cellCount := oldCellCount
		    end if


		label kindT.choose :

		    % update parse stack (for choose and order nodes only!)
		    if parseDepth >= maxParseDepth then
			error ("(Fatal) Maximum parse depth exceeded", WARNING)
			quit : parseTooDeep
		    end if

		    parseStack (parseDepth) := nodes (patternNP).name

		    % Check for infinite parse loop
		    if (parseDepth - parseScan.depthOfLastAccept) > maxBlindParseDepth then
			% we're deep - better check for an infinite loop!
			for pd : parseScan.depthOfLastAccept + 1 .. parseDepth - 1
			    if parseStack (pd) = nodes (patternNP).name then
				% the never-ending story ...
				if node_print_p then 
				    put:0, "TXL Info: Gave up on infinite parse loop on '",
					identTable (nodes (patternNP).name),
					"' with lookahead '", identTable (parseScan.nextToken), "'"
				end if

				parseNP := nilNode
				parseDepth -= 1
				return
			    end if
			end for
		    end if

		    % recover wasted space if we fail
		    const oldCellCount := cellCount
		    const oldNodeCount := nodeCount

		    var patternKidsCP := nodes (patternNP).kidsCP
		    const productionKids := nodes (patternNP).count
		    var parseKidNP : nodePT := nilNode

		    assert parseNP = nilNode

		    % try each alternative until we get a match
		    for kid : 1 .. productionKids

			real_parse (cells (patternKidsCP).firstNP, parseKidNP)

			if parseKidNP not= nilNode then
			    % one success is all we need
			    newNode (parseNP)
			    nodes (parseNP) := nodes (patternNP) % sets kind and name
			    % encode choice we made in the parse node, in case we must retry
			    nodes (parseNP).count := kid
			    newCell (nodes (parseNP).kidsCP)
			    cells (nodes (parseNP).kidsCP).firstNP := parseKidNP
			    cells (nodes (parseNP).kidsCP).restCP := nilCell
			    exit
			end if

			% try the next alternative
			patternKidsCP := cells (patternKidsCP).restCP

			% subsequent tries must be with nil nodes!
			parseKidNP := nilNode
		    end for

		    if parseNP = nilNode then
			% recover wasted space
			nodeCount := oldNodeCount
			cellCount := oldCellCount
		    end if




		% Terminals

		label kindT.literal :
		    % don't care what it is, but it must match exactly
		    assert parseNP = nilNode
		    if parseScan.nextToken = nodes (patternNP).name then
			%  accept
			newNode (parseNP)
			nodes (parseNP) := nodes (patternNP)
			parseScan.accept
		    end if

		label kindT.stringlit :
		    assert parseNP = nilNode
		    if parseScan.nextTokenKind = kindT.stringlit then
			%  accept
			newNode (parseNP)
			nodes (parseNP) := nodes (patternNP)
			nodes (parseNP).name := parseScan.nextToken 
			parseScan.accept
		    end if

		label kindT.charlit :
		    assert parseNP = nilNode
		    if parseScan.nextTokenKind = kindT.charlit then
			%  accept
			newNode (parseNP)
			nodes (parseNP) := nodes (patternNP)
			nodes (parseNP).name := parseScan.nextToken 
			parseScan.accept
		    end if

		label kindT.number :
		    assert parseNP = nilNode
		    if parseScan.nextTokenKind = kindT.number then
			%  accept
			newNode (parseNP)
			nodes (parseNP) := nodes (patternNP)
			nodes (parseNP).name := parseScan.nextToken 
			parseScan.accept
		    end if

		label kindT.floatnumber :
		    assert parseNP = nilNode
		    const tokenText := identTable (parseScan.nextToken)
		    if parseScan.nextTokenKind = kindT.number 
			    and (index (tokenText, "e") not= 0 
				or index (tokenText, "E") not= 0) then
			%  accept
			newNode (parseNP)
			nodes (parseNP) := nodes (patternNP)
			nodes (parseNP).name := parseScan.nextToken 
			parseScan.accept
		    end if

		label kindT.decimalnumber :
		    assert parseNP = nilNode
		    const tokenText := identTable (parseScan.nextToken)
		    if parseScan.nextTokenKind = kindT.number 
			    and index (tokenText, ".") not= 0 then 
			%  accept
			newNode (parseNP)
			nodes (parseNP) := nodes (patternNP)
			nodes (parseNP).name := parseScan.nextToken 
			parseScan.accept
		    end if

		label kindT.integernumber :
		    assert parseNP = nilNode
		    if parseScan.nextTokenKind = kindT.number then
			const tokenText := identTable (parseScan.nextToken)
			const textLength := length (tokenText)
			for d : 1 .. textLength
			    const nextchar : char := tokenText (d)
			    exit when not digitP (nextchar)
			    if d = textLength then
				%  accept
				newNode (parseNP)
				nodes (parseNP) := nodes (patternNP)
				nodes (parseNP).name := parseScan.nextToken 
				parseScan.accept
			    end if
			end for
		    end if

		label kindT.id :
		    % any id not a keyword
		    assert parseNP = nilNode
		    if parseScan.nextTokenKind = kindT.id then
			%  accept
			newNode (parseNP)
			nodes (parseNP) := nodes (patternNP)
			nodes (parseNP).name := parseScan.nextToken 
			parseScan.accept
		    end if

		label kindT.upperlowerid :
		    assert parseNP = nilNode
		    const firstchar : char := 
			identTable (parseScan.nextToken) (1)
		    if parseScan.nextTokenKind = kindT.id 
			    and upperP (firstchar) then
			%  accept
			newNode (parseNP)
			nodes (parseNP) := nodes (patternNP)
			nodes (parseNP).name := parseScan.nextToken 
			parseScan.accept
		    end if

		label kindT.lowerupperid :
		    assert parseNP = nilNode
		    const firstchar : char := 
			identTable (parseScan.nextToken) (1)
		    if parseScan.nextTokenKind = kindT.id 
			    and lowerP (firstchar) then
			%  accept
			newNode (parseNP)
			nodes (parseNP) := nodes (patternNP)
			nodes (parseNP).name := parseScan.nextToken 
			parseScan.accept
		    end if

		label kindT.upperid :
		    assert parseNP = nilNode
		    if parseScan.nextTokenKind = kindT.id then
			const tokenText := identTable (parseScan.nextToken)
			const textLength := length (tokenText)
			for d : 1 .. textLength
			    const nextchar : char := tokenText (d)
			    exit when not upperP (nextchar)
			    if d = textLength then
				%  accept
				newNode (parseNP)
				nodes (parseNP) := nodes (patternNP)
				nodes (parseNP).name := parseScan.nextToken 
				parseScan.accept
			    end if
			end for
		    end if

		label kindT.lowerid :
		    assert parseNP = nilNode
		    if parseScan.nextTokenKind = kindT.id then
			const tokenText := identTable (parseScan.nextToken)
			const textLength := length (tokenText)
			for d : 1 .. textLength
			    const nextchar : char := tokenText (d)
			    exit when not lowerP (nextchar)
			    if d = textLength then
				%  accept
				newNode (parseNP)
				nodes (parseNP) := nodes (patternNP)
				nodes (parseNP).name := parseScan.nextToken 
				parseScan.accept
			    end if
			end for
		    end if

		label kindT.token :
		    % generic token - used only for TXL source itself 
		    % anything is ok unless it's a key symbol
		    % whatever it is, it retains its own kind!
		    assert parseNP = nilNode
		    const tokenKind := parseScan.nextTokenKind
		    if tokenKind not= kindT.key and tokenKind not= kindT.empty then
			%  accept
			newNode (parseNP)
			nodes (parseNP) := nodes (patternNP)
			nodes (parseNP).kind := tokenKind
			nodes (parseNP).name := parseScan.nextToken 
			parseScan.accept
		    end if

		label kindT.key :
		    % generic keyword - used only for TXL source itself
		    assert parseNP = nilNode
		    if parseScan.nextTokenKind = kindT.key then
			newNode (parseNP)
			nodes (parseNP) := nodes (patternNP)
			nodes (parseNP).name := parseScan.nextToken 
			parseScan.accept
		    end if

		label kindT.firstTime, kindT.subsequentUse, 
			kindT.expression, kindT.ruleCall, kindT.undefined :
		    error ("Fatal TXL error in parse", FATAL)
	    end case



	else

	    % Backup

	    if node_print_p then
		put : 0, repeat (".", parseDepth), "?", identTable (nodes (patternNP).name) ..
		put : 0, " <-*-> " ..
		if parseScan.nextToken = emptyT then
		    put : 0, " EOF"
		else
		    put : 0, " ", identTable (parseScan.nextToken)
		end if
		put : 0, "--> RETRY IN PROGRESS.  Parse Tree passed to me was..."
		printParse (parseNP, 0, true)
	    end if


	    % No infinite loop check since this is a retry!


	    case nodes (patternNP).kind of

		label kindT.empty :

		    % backing up match of empty!!
		    parseNP := nilNode


		label kindT.order :

		    % Retrying an order node

		    % update parse stack (for choose and order nodes only!)
		    assert parseDepth < maxParseDepth 	% must be so, if we are retrying!
		    parseStack (parseDepth) := nodes (patternNP).name

		    % recover wasted space if we fail
		    const oldCellCount := cellCount
		    const oldNodeCount := nodeCount

		    % required for fancy parser speedup!
		    assert trees.contiguousKids (patternNP)

		    const productionKids := nodes (patternNP).count

		    % Now we parse!
		    % Undo previous matches in reverse order on retry.
		    % since kids of productions are contiguous cells, we
		    % can simply walk up and down them directly!
		    const baseProductionKidCP := nodes (patternNP).kidsCP - 1

		    % since the kid cells of the previous parse were also allocated
		    % contiguously, we can use them in place too!
		    const baseParseKidCP := nodes (parseNP).kidsCP - 1

		    var retry := true

		    var kid := productionKids
		    loop
			const oldTokenHandle := tokenHandle

			real_parse (cells (baseProductionKidCP + kid).firstNP, 
				    cells (baseParseKidCP + kid).firstNP)

			if cells (baseParseKidCP + kid).firstNP = nilNode then
			    kid -= 1
			    exit when kid = 0
			    retry := true
			elsif retry => tokenHandle not= oldTokenHandle then
			    kid += 1
			    exit when kid = productionKids + 1
			    retry := false
			    cells (baseParseKidCP + kid).firstNP := nilNode
			% else
			    % re-parses of an embedded kid that yield the 
			    % same lookahead are uninteresting since the 
			    % rest will fail in the same way!
			    %  - so ask for another try of the same kid
			end if
		    end loop

		    % we fail if we're at the left, 
		    % succeed if we made it all the way to the right
		    % all kids are already in place!

		    if kid = 0 then
			parseNP := nilNode
			% recover wasted space
			nodeCount := oldNodeCount
			cellCount := oldCellCount
		    end if


		label kindT.choose :

		    % Retrying a choose node

		    % update parse stack (for choose and order nodes only!)
		    assert parseDepth <= maxParseDepth 	% must be so, if we are retrying!
		    parseStack (parseDepth) := nodes (patternNP).name

		    % recover wasted space if we fail
		    const oldCellCount := cellCount
		    const oldNodeCount := nodeCount

		    const productionKids := nodes (patternNP).count

		    % nodes (parseNP).count encodes the number of the choice 
		    % we used last time.
		    % first we give that one a chance to retry, 
		    % then try the other alternatives if it fails.

		    const kidLastTime := nodes (parseNP).count

		    % first time through we re-try the last match 
		    var parseKidNP : nodePT := cells (nodes (parseNP).kidsCP).firstNP
		    % since kids are kept contiguous, we can address the corresponding
		    % production kid directly!
		    var patternKidsCP := nodes (patternNP).kidsCP + kidLastTime - 1

		    % OK -- we loop until we get a new match!
		    for kid : kidLastTime .. productionKids

			real_parse (cells (patternKidsCP).firstNP, parseKidNP)

			if parseKidNP not= nilNode then
			    % one success is all we need
			    % we re-use the node and cell structure we allocated 
			    % on the first try
			    cells (nodes (parseNP).kidsCP).firstNP := parseKidNP
			    % encode choice we made in the parse node, 
			    % in case we must retry again
			    nodes (parseNP).count := kid
			    exit
			end if

			% try the next alternative
			patternKidsCP := cells (patternKidsCP).restCP

			% subsequent tries must be with nil nodes!
			parseKidNP := nilNode
		    end for

		    if parseKidNP = nilNode then
			parseNP := nilNode
			% recover wasted space
			nodeCount := oldNodeCount
			cellCount := oldCellCount
		    end if

		label kindT.literal, kindT.stringlit, kindT.charlit, kindT.token,
			kindT.id, kindT.upperlowerid, kindT.upperid, 
			kindT.lowerupperid, kindT.lowerid, kindT.number,
			kindT.floatnumber, kindT.decimalnumber, kindT.integernumber,
			kindT.key :
		    % Retrying a terminal - only thing left to do is back up!
		    parseNP := nilNode
		    parseScan.backup

		label kindT.firstTime, kindT.subsequentUse, kindT.expression,
			kindT.ruleCall, kindT.undefined :
		    error ("Fatal TXL error in parse", FATAL)
	    end case

	end if

	if node_print_p then
	    if parseNP = nilNode then
		put : 0, repeat (".", parseDepth), "#", identTable (nodes (patternNP).name) ..
		if parseScan.nextToken = emptyT then
		    put : 0, " EOF"
		else
		    put : 0, " ", identTable (parseScan.nextToken)
		end if
	    else
		put : 0, repeat (".", parseDepth), "!", identTable (nodes (patternNP).name)
	    end if
	end if

	parseDepth -= 1

    end real_parse


    body procedure parse %(patternNP : nodePT, var parseNP : nodePT, var fail : boolean)
	handler (code)
	    if code = outOfCells or code = outOfNodes or code = parseTooDeep then
		fail := true
		return
	    end if
	    quit > : code
	end handler

	real_parse (patternNP, parseNP)
	fail := parseNP = nilNode
    end parse

end parser
%#if not NOCOMPILE then
    %child "compile_defines.ch"
% TXL v6.0 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

%parent "txl.t"

stub module defineCompiler
    import (enterSymbol, var nodes, var cells, newNode, newCell, var trees,
        var keywordTokens, var nKeys, sortKeys, findSymbol, lookupSymbol, var ident, var identTable,
        var symbolTable, var symbolTableSize, maxSymbols, error)

    export (makeGrammarTree)

    procedure makeGrammarTree (txlParseTreeNP : nodePT, var objectGrammarTreeNP : nodePT)

end defineCompiler


body module defineCompiler

    procedure processKeys (keysNP : nodePT)
        var literalsLeftNP : nodePT := trees.keys_literalsNP (keysNP)
        assert identTable (nodes (literalsLeftNP).name) = "TXL_literals_"
        loop
            exit when trees.plural_emptyP (literalsLeftNP)
            nKeys += 1

            if nKeys > maxKeys then
                error ("Too many keywords in TXL specification (maximum " +
		    intstr (maxKeys, 1) + ")", FATAL)
            end if

            const literalNP := trees.plural_firstNP (literalsLeftNP)

	    keywordTokens (nKeys) := trees.literal_tokenT (literalNP)

            literalsLeftNP := trees.plural_restNP (literalsLeftNP)
        end loop

	sortKeys
    end processKeys


    procedure processOpt (XT : tokenT, var optNP : nodePT)

	%  [opt X]   ==>   opt__X  where
	%	opt__X     -->   [X]   |   [empty]

	% First check to see if we've already done one of these
	var optXindex : tokenT := ident.lookup ("opt__" + identTable  (XT))
	var optIndex : int

	if optXindex not= NOT_FOUND then
	    % We're in luck, one exists already, so share it!
	    lookupSymbol (optXindex, optIndex)
	    assert optIndex not= -1	% if the ident's defined, it better exist as a symbol also!
	    optNP := symbolTable (optIndex)

	else
	    % It's a new one, so build it
	    var Xindex : int
	    enterSymbol (XT, Xindex)
	    const XNP := symbolTable (Xindex)
	
	    const X := identTable (XT)
	    ident.install ("opt__" + X,  optXindex)
	    enterSymbol (optXindex, optIndex)
	    optNP := symbolTable (optIndex)
	    nodes (optNP).kind := kindT.choose
	
	    trees.makeTwoKids (optNP, XNP, emptyNP)
	end if

    end processOpt


    procedure processRepeat (XT : tokenT, var repeatNP : nodePT, var  repeatFirstNP : nodePT)

	%  [repeat X]   ==>   repeat__X  where
	%	repeat__X     -->   [repeat_1_X]   |   [empty]
	%	repeat_1_X   -->   [X]  [repeat__X]

	% First check to see if we've already done one of these
	var repeatXtoken : tokenT := ident.lookup ("repeat__" + identTable  (XT))
	var repeatFirstToken : tokenT
	var repeatIndex, repeatFirstIndex : int

	if repeatXtoken not= NOT_FOUND then
	    % We're in luck, one exists already, so share it!
	    lookupSymbol (repeatXtoken, repeatIndex)
	    assert repeatIndex not= -1	% if the ident's defined, it better exist as a symbol also!
	    repeatNP := symbolTable (repeatIndex)
	    repeatFirstToken := ident.lookup ("repeat_1_" + identTable  (XT))
	    lookupSymbol (repeatFirstToken, repeatFirstIndex)
	    assert repeatFirstIndex not= -1	% ditto
	    repeatFirstNP := symbolTable (repeatFirstIndex)

	else
	    % It's a new one, so build it
	    var Xindex : int
	    enterSymbol (XT, Xindex)
	    const XNP := symbolTable (Xindex)
	
	    const X := identTable (XT)
	    ident.install ("repeat__" + X,  repeatXtoken)
	    enterSymbol (repeatXtoken, repeatIndex)
	    repeatNP := symbolTable (repeatIndex)
	    nodes (repeatNP).kind := kindT.choose
	
	    ident.install ("repeat_1_" + X, repeatFirstToken)
	    enterSymbol (repeatFirstToken, repeatFirstIndex)
	    repeatFirstNP := symbolTable (repeatFirstIndex)
	    nodes (repeatFirstNP).kind := kindT.order
	
	    trees.makeTwoKids (repeatFirstNP, XNP, repeatNP)
	    trees.makeTwoKids (repeatNP, repeatFirstNP, emptyNP)
	end if

    end processRepeat


    procedure processList (XT :tokenT, var listNP: nodePT, listFirstNP : nodePT)

	%  [list X]   ==>   list__X  where
	%	list__X    		    -->    [list_1_X]   |   [empty]
	%	list_1_X  		    -->    [X]  [list_opt_rest_X]
	%	list_opt_rest_X   -->    [list_rest_X]   |   [empty]
	%	list_rest_X    	    -->    ,  [list_1_X]

	% First check to see if we've already done one of these
	var listXtoken : tokenT := ident.lookup ("list__" + identTable (XT))
	var listFirstToken : tokenT
	var listIndex, listFirstIndex : int


	if listXtoken not= NOT_FOUND then
	    % We're in luck, one exists already, so share it!
	    lookupSymbol (listXtoken, listIndex)
	    assert listIndex not= -1		% if the ident's defined, it better exist as a symbol also!
	    listNP := symbolTable (listIndex)
	    listFirstToken := ident.lookup ("list_1_" + identTable  (XT))
	    lookupSymbol (listFirstToken, listFirstIndex)
	    assert listFirstIndex not= -1	% ditto
	    listFirstNP := symbolTable (listFirstIndex)

	else
	    % It's a new one, so build it
	    var listOptRestToken, listCommaRestToken : tokenT
	    var listOptRestIndex, listCommaRestIndex : int

	    var Xindex : int
	    enterSymbol (XT, Xindex)
	    const XNP := symbolTable (Xindex)

	    const X := identTable (XT)
	    ident.install ("list__" + identTable (XT), listXtoken)
	    enterSymbol (listXtoken, listIndex)
	    listNP := symbolTable (listIndex)
	    nodes (listNP).kind := kindT.choose

	    ident.install ("list_1_" + X, listFirstToken)
	    enterSymbol (listFirstToken, listFirstIndex)
	    listFirstNP := symbolTable (listFirstIndex)
	    nodes (listFirstNP).kind := kindT.order

	    ident.install ("list_opt_rest_" + X, listOptRestToken)
	    enterSymbol (listOptRestToken, listOptRestIndex)
	    const listOptRestNP := symbolTable (listOptRestIndex)
	    nodes (listOptRestNP).kind := kindT.choose

	    ident.install ("list_rest_" + X, listCommaRestToken)
	    enterSymbol (listCommaRestToken, listCommaRestIndex)
	    const listCommaRestNP := symbolTable (listCommaRestIndex)
	    nodes (listCommaRestNP).kind := kindT.order

	    trees.makeTwoKids (listCommaRestNP, commaNP, listFirstNP)
	    trees.makeTwoKids (listOptRestNP, listCommaRestNP, emptyNP)
	    trees.makeTwoKids (listFirstNP, XNP, listOptRestNP)
	    trees.makeTwoKids (listNP, listFirstNP, emptyNP)
	end if
	
    end processList


    procedure makeListRepeatOrOptTargetT (idOrLiteralNP : nodePT, 
	    var targetT : tokenT)
  
	pre identTable (nodes (idOrLiteralNP).name) = "TXL_idOrLiteral_"
	assert identTable (nodes (trees.kid1NP (idOrLiteralNP)).name) = "TXL_literal_" or
		nodes (trees.kid1NP (idOrLiteralNP)).kind = kindT.id

	if trees.literalP (trees.kid1NP (idOrLiteralNP)) then
	    % it's a literal, so make a phoney nonterminal for it
	    assert identTable (nodes (trees.kid1NP (idOrLiteralNP)).name) = "TXL_literal_"
            const terminalT : tokenT := 
		trees.literal_tokenT (trees.kid1NP (idOrLiteralNP))
            var terminalNP : nodePT
	    newNode (terminalNP)
            nodes (terminalNP).kind := kindT.literal
            nodes (terminalNP).name := terminalT
	    const terminal := identTable (terminalT)
	    var targetIndex : int
	    ident.install ("lit__" + terminal, targetT)
	    enterSymbol (targetT, targetIndex)
	    const targetNP := symbolTable (targetIndex)
	    nodes (targetNP).kind := kindT.order
	    trees.makeOneKid (targetNP, terminalNP)
	else
	    % it's a nonterminal id, so simply return it
	    assert nodes (trees.kid1NP (idOrLiteralNP)).kind = kindT.id
	    const idNP : nodePT := trees.kid1NP (idOrLiteralNP)
	    targetT := nodes (idNP).name
	end if
	    
    end makeListRepeatOrOptTargetT
    
    
    procedure processOneKid (literalOrBracketedIdNP : nodePT, var kidNP : nodePT)

        var dummyNP : nodePT
	
	const literalOrBracketedId_kid1NP : nodePT := 
	    trees.kid1NP (literalOrBracketedIdNP)

	if trees.literalP (literalOrBracketedId_kid1NP) then
            % terminal
            const terminalT : tokenT := trees.literal_tokenT (literalOrBracketedId_kid1NP)
            newNode (kidNP)
            nodes (kidNP).kind := kindT.literal
            nodes (kidNP).name := terminalT

	elsif trees.listP (literalOrBracketedId_kid1NP) then
            % [list X]
	    const XNP : nodePT := trees.bracketedDescription_listRepeatOrOptTargetNP 
		(literalOrBracketedId_kid1NP)
	    var XT : tokenT 
	    makeListRepeatOrOptTargetT (XNP, XT)
	    processList (XT, kidNP, dummyNP)
 
        elsif trees.list1P (literalOrBracketedId_kid1NP) then
            % [list1 X]
	    const XNP : nodePT := trees.bracketedDescription_listRepeatOrOptTargetNP 
		(literalOrBracketedId_kid1NP)
	    var XT : tokenT  
	    makeListRepeatOrOptTargetT (XNP, XT)
	    processList (XT, dummyNP, kidNP)
 
	elsif trees.repeatP (literalOrBracketedId_kid1NP) then
	    % [repeat X]
	    const XNP : nodePT := trees.bracketedDescription_listRepeatOrOptTargetNP 
		(literalOrBracketedId_kid1NP)
	    var XT : tokenT 
	    makeListRepeatOrOptTargetT (XNP, XT)
	    processRepeat (XT, kidNP, dummyNP)
 
	elsif trees.repeat1P (literalOrBracketedId_kid1NP) then
	    % [repeat1 X]
	    const XNP : nodePT := trees.bracketedDescription_listRepeatOrOptTargetNP 
		(literalOrBracketedId_kid1NP)
	    var XT : tokenT 
	    makeListRepeatOrOptTargetT (XNP, XT)
	    processRepeat (XT, dummyNP, kidNP)

	elsif trees.optP (literalOrBracketedId_kid1NP) then
	    % [opt X]
	    const XNP : nodePT := trees.bracketedDescription_listRepeatOrOptTargetNP 
		(literalOrBracketedId_kid1NP)
	    var XT : tokenT 
	    makeListRepeatOrOptTargetT (XNP, XT)
	    processOpt (XT, kidNP)
 
        elsif trees.bracketedDescriptionP (literalOrBracketedId_kid1NP) then
            % [X]
	    const XT : tokenT := 
		trees.bracketedDescription_idT (literalOrBracketedId_kid1NP)
	    var kidIndex : int
            enterSymbol (XT, kidIndex)
            kidNP := symbolTable (kidIndex)

        else
	    error ("Fatal TXL error in processOneKid", FATAL)
        end if

	assert (nodes (kidNP).kind = kindT.order or nodes (kidNP).kind = kindT. choose)
	    => trees.contiguousKids (kidNP)
    end processOneKid


    procedure processKids (kidsNP : nodePT, parentIndex : int)

	pre not trees.plural_emptyP (kidsNP) 

	const parentNP := symbolTable (parentIndex)

	% pre-reserve the kid cells to keep them contiguous -
	% necessary for high-falutin' parser speedups!
	var kidsToCountNP := kidsNP
	var kidListCP : cellPT
	newCell (kidListCP)
	nodes (parentNP).kidsCP := kidListCP
	nodes (parentNP).count := 1
	loop
	    kidsToCountNP := trees.plural_restNP (kidsToCountNP)
	    exit when trees.plural_emptyP (kidsToCountNP)

	    if nodes (parentNP).count = maxKids then
		error ("In TXL specification, too many elements or alternatives in one define",
		   FATAL)
	    end if

	    nodes (parentNP).count += 1
	    newCell (cells (kidListCP).restCP)
	    kidListCP := cells (kidListCP).restCP
	end loop
	cells (kidListCP).restCP := nilCell

	% Now fill them in
	var kidsLeftToProcessNP := kidsNP
	kidListCP := nodes (parentNP).kidsCP
	for kid : 1 .. nodes (parentNP).count
	    const literalOrBracketedIdNP := trees.plural_firstNP (kidsLeftToProcessNP)
	    assert trees.literalOrBracketedIdP (literalOrBracketedIdNP)

	    processOneKid (literalOrBracketedIdNP, cells (kidListCP).firstNP)

	    kidsLeftToProcessNP := trees.plural_restNP (kidsLeftToProcessNP)
	    kidListCP := cells (kidListCP).restCP
	end for
	assert kidListCP = nilCell

	assert trees.contiguousKids (parentNP)

    end processKids


    procedure checkUserDefinedName (name : tokenT)
        if index (identTable (name), "list_") = 1 or
                index (identTable (name), "repeat_") = 1 or
                index (identTable (name), "opt_") = 1 then
	    error ("Illegal define name " + identTable (name) + " in TXL specification\n" +
                "  ('list_', 'repeat_' and 'opt_' prefixes are reserved for TXL internal use)", 
		FATAL)
        end if
    end checkUserDefinedName


    procedure generateNewNameT (nameT : tokenT, var newNameT : tokenT)
        % Generate an illegal name so user can't use it
        %     >>--  Leading underscores are not legal
        const baseName := identTable (nameT)
        var newName : tokenValueT
        var newToken : tokenT
        for i : 1 .. 1000
            newName := "__" + baseName + "_" + intstr (i) + "__"
            exit when ident.lookup (newName) = NOT_FOUND
        end for
        ident.install (newName, newToken)
        newNameT := newToken
    end generateNewNameT


    procedure processDefine (defineNP : nodePT)

        var symbolIndex : int
        const defineNameT := trees.define_nameT (defineNP)
        const literalsAndBracketedIds := trees.define_literalsAndBracketedIdsNP (defineNP)
        const barOrders := trees.define_barOrdersNP (defineNP)

        checkUserDefinedName (defineNameT)

        if trees.plural_emptyP (barOrders) then
            enterSymbol (defineNameT, symbolIndex)
            nodes (symbolTable (symbolIndex)).kind := kindT.order

            if trees.plural_emptyP (literalsAndBracketedIds) then
                error ("In TXL specification, in define '" + identTable (defineNameT) + "',\n" +
                    "  empty defines not allowed - use [empty].", FATAL)
	    end if

            processKids (literalsAndBracketedIds, symbolIndex)

        else
            enterSymbol (defineNameT, symbolIndex)
            nodes (symbolTable (symbolIndex)).kind := kindT.choose
            nodes (symbolTable (symbolIndex)).kidsCP := nilCell

            if trees.plural_emptyP (literalsAndBracketedIds) then
                error ("In TXL specification, in define '" + identTable (defineNameT) + "',\n" +
                    "  empty defines not allowed - use [empty].", FATAL)
	    end if

	    % pre-reserve the kid cells to keep them contiguous -
	    % necessary for high-falutin' parser speedups!
            var kidsToCountNP := barOrders
	    var kidListCP : cellPT
	    newCell (kidListCP)
	    nodes (symbolTable (symbolIndex)).kidsCP := kidListCP
	    nodes (symbolTable (symbolIndex)).count := 1
	    loop
		exit when trees.plural_emptyP (kidsToCountNP)

		if nodes (symbolTable (symbolIndex)).count = maxKids then
		    error ("In TXL specification, too many elements or alternatives in one define",
		       FATAL)
		end if

		nodes (symbolTable (symbolIndex)).count += 1
		newCell (cells (kidListCP).restCP)
		kidListCP := cells (kidListCP).restCP

                kidsToCountNP := trees.kid3NP (trees.kid1NP (kidsToCountNP))
	    end loop
	    cells (kidListCP).restCP := nilCell

            kidListCP := nodes (symbolTable (symbolIndex)).kidsCP

            if trees.plural_emptyP (trees.plural_restNP (literalsAndBracketedIds)) then
                processOneKid (trees.plural_firstNP (literalsAndBracketedIds),
                    cells (kidListCP).firstNP)
            else
                var newSymIndex : int
                var newNameT : tokenT
		generateNewNameT (defineNameT, newNameT)
                enterSymbol (newNameT, newSymIndex)
                nodes (symbolTable (newSymIndex)).kind := kindT.order
                processKids (literalsAndBracketedIds, newSymIndex)
                cells (kidListCP).firstNP := symbolTable (newSymIndex)
            end if

	    kidListCP := cells (kidListCP).restCP

            var nextBarOrders := barOrders

            for barOrder : 2 .. nodes (symbolTable (symbolIndex)).count
                % LAndBIds == LiteralsAndBracketedIds
                var nextLAndBIdsNP := trees.kid2NP (trees.kid1NP (nextBarOrders))

                if trees.plural_emptyP (nextLAndBIdsNP) then
		    error ("In TXL specification, in define '" + identTable (defineNameT) + "',\n" +
			"  empty alternatives not allowed - use [empty].", FATAL)
		end if

                if trees.plural_emptyP (trees.plural_restNP (nextLAndBIdsNP)) then
                    processOneKid (trees.plural_firstNP (nextLAndBIdsNP), cells (kidListCP).firstNP)
                else
                    var newSymIndex : int
                    var newNameT : tokenT
		    generateNewNameT (defineNameT, newNameT)
                    enterSymbol (newNameT, newSymIndex)
                    nodes (symbolTable (newSymIndex)).kind := kindT.order
                    processKids (nextLAndBIdsNP, newSymIndex)
                    cells (kidListCP).firstNP := symbolTable (newSymIndex)
                end if

                nextBarOrders := trees.kid3NP (trees.kid1NP (nextBarOrders))
		kidListCP := cells (kidListCP).restCP
            end for
	    assert kidListCP = nilCell

        end if

	assert trees.contiguousKids (symbolTable (symbolIndex))
    end processDefine


    procedure setUpBuiltins
        var symbolIndex : int
        var identIndex : tokenT

	ident.install ("stringlit", identIndex)
	enterSymbol (identIndex, symbolIndex)
	nodes (symbolTable (symbolIndex)).kind := kindT.stringlit

	ident.install ("charlit", identIndex)
	enterSymbol (identIndex, symbolIndex)
	nodes (symbolTable (symbolIndex)).kind := kindT.charlit

	ident.install ("number", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.number

	ident.install ("floatnumber", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.floatnumber

	ident.install ("decimalnumber", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.decimalnumber

	ident.install ("integernumber", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.integernumber

        ident.install ("id", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.id

        ident.install ("upperlowerid", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.upperlowerid

        ident.install ("upperid", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.upperid

        ident.install ("lowerupperid", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.lowerupperid

        ident.install ("lowerid", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.lowerid

        ident.install ("token", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.token

        ident.install ("key", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.key

	ident.install ("empty", identIndex)
	enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.empty

	% for historical reasons, retain old emptyString
	ident.install ("emptyString", identIndex)
	enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.empty

	% new output paragraphing symbols
        ident.install ("NL", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.empty

        ident.install ("IN", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.empty

        ident.install ("EX", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.empty

        ident.install ("SP", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.empty

        ident.install ("SPOFF", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.empty

        ident.install ("SPON", identIndex)
        enterSymbol (identIndex, symbolIndex)
        nodes (symbolTable (symbolIndex)).kind := kindT.empty
    end setUpBuiltins


    body procedure makeGrammarTree %( txlParseTreeNP : nodePT, var objectGrammarTreeNP : nodePT)
        var symbolIndex : int
        var identIndex : tokenT

        % root production of object language
        ident.install ("program", identIndex)
        enterSymbol (identIndex, symbolIndex)
        objectGrammarTreeNP := symbolTable (symbolIndex) 

        % make sure our symbolTable has the builtins in it
        setUpBuiltins

	% and we have our own keyword table
	nKeys := 0

        % now process the keyword lists and productions of the object language grammar
        var statementsLeftNP := trees.program_statementsNP (txlParseTreeNP)

        loop
            exit when trees.plural_emptyP (statementsLeftNP)

            const statementNP :=
                trees.statement_keyDefRuleNP (trees.plural_firstNP (statementsLeftNP))
            const statementKind := identTable (nodes (statementNP).name)

            if statementKind = "TXL_keysStatement_" then
                processKeys (statementNP)
            elsif statementKind = "TXL_defineStatement_" then
                processDefine (statementNP)
            else
                assert statementKind = "TXL_ruleStatement_" or
                    statementKind = "TXL_functionStatement_" or
                    statementKind = "TXL_externalStatement_"
                % do nothing for now, handle when we build the rule symbolTable later
            end if

            statementsLeftNP := trees.plural_restNP (statementsLeftNP)
        end loop

        % Check that there are no undefined symbols
        var errorcount := 0

        for i : 1 .. symbolTableSize
            if nodes (symbolTable (i)).kind = kindT.undefined then
                error ("In TXL specification, symbol '" +
		    identTable (nodes (symbolTable (i)).name) +
                    "' has not been defined", WARNING)
                errorcount += 1
            end if
        end for

        if errorcount not= 0 then
            quit
        end if

    end makeGrammarTree

end defineCompiler
    %child "compile_rules.ch"
% TXL 6.0 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

%parent "txl.t"

stub module ruleCompiler
    import (enterRuleName, var nodes, var cells, newNode, newCell, var nodeCount, var cellCount,
	var trees, findSymbol, symbolTable, 
	maxSymbols, numberP, letterP, keyP, lowerP, upperP, digitP,
        node_print_p, parse_print_p, printParse,
        var ident, var identTable, var rules, var ruleCount, 
        printSkippedToken, enterLocalVar, findLocalVar, lookupLocalVar,
	error, patternError)

    export (makeRuleTable)

    procedure makeRuleTable (txlParseTreeNP : nodePT)

end ruleCompiler


body module ruleCompiler

    % Global pre-hashed names for speed
    var eachT : tokenT

    % Scanning of semi-parsed rule patterns and replacements
    var buildDepth := -1
    var buildStack : array 0 .. maxParseDepth of tokenT
    
    var buildNodes : array 1 .. maxPatternTokens of nodePT
    var buildHandle, lastBuildHandle, failBuildHandle : 0 .. maxPatternTokens
    var depthTokenAccepted : array 1 .. maxPatternTokens of 0 .. maxPatternTokens % (sic)
    
    module buildScan
	import (var buildNodes, var buildHandle, var lastBuildHandle, var failBuildHandle,
	    var depthTokenAccepted, buildDepth, tokenT, var trees, keyP)

	export (initialize, accept, backup, nextToken, nextTokenKind, restOfPattern, 
	    depthOfLastAccept)
    
        % The purpose of this module is to provide a clean interface to
        % raw patterns and replacements as a stream of tokens 
	% consistent with parseScan in parser.ch.  In this way we can use
	% essentially the same parsing algorithm to parse patterns and
	% replacements as we use to parse input source.
        %
        % buildScan provides the following routines
        %
        % initialize 		starts scanning a particular raw pattern/replacement
        % accept 		advances the input one token
        % backup 		backs the input up one token
        % nextToken	 	returns the next (current) token
        % restOfPattern		returns node pointer to the unparsed rest of the pattern/replacement
        % depthOfLastAccept 	returns the parse depth when the token before
        %			    the current one was accepted

	procedure initialize (litsAndVarsAndExpsNP : nodePT)
	    var lves := litsAndVarsAndExpsNP
	    lastBuildHandle := 0
	    loop
		lastBuildHandle += 1
		buildNodes (lastBuildHandle) := lves
		exit when trees.plural_emptyP (lves)
		lves := trees.plural_restNP (lves)
	    end loop
	    buildHandle := 1
	    failBuildHandle := 1
	    depthTokenAccepted (1) := 0
	end initialize
    
	function restOfPattern : nodePT
	    result buildNodes (buildHandle)
	end restOfPattern
    
	procedure accept
	    buildHandle += 1
	    depthTokenAccepted (buildHandle) := buildDepth

	    if buildHandle > failBuildHandle then
		failBuildHandle := buildHandle
	    end if
	end accept
    
	procedure backup
	    buildHandle -= 1
	end backup
    
	function depthOfLastAccept : int
	    result depthTokenAccepted (buildHandle)
	end depthOfLastAccept
    
	function nextToken : tokenT
	    if buildHandle = lastBuildHandle then
		result emptyT
	    else
		result trees.literal_tokenT 
		    (trees.kid1NP (trees.plural_firstNP (buildNodes (buildHandle))))
	    end if
	end nextToken

	function nextTokenKind : kindT
	    if buildHandle = lastBuildHandle then
		result kindT.empty
	    else
		const rawkind := trees.literal_kindT 
		    (trees.kid1NP (trees.plural_firstNP (buildNodes (buildHandle))))
		if rawkind = kindT.id then
		    if keyP (nextToken) then
			result kindT.key
		    else
			result kindT.id
		    end if
		else
		    result rawkind
		end if
	    end if
	end nextTokenKind
    
    end buildScan
    


    procedure buildRuleCall (ruleCallNP : nodePT, var varsSoFar : localsListT,
	    var parsedCallNP : nodePT, isCondition : boolean)
    
	newNode (parsedCallNP)
	nodes (parsedCallNP).kind := kindT.ruleCall
	nodes (parsedCallNP).name := trees.ruleCall_nameT (ruleCallNP)
	nodes (parsedCallNP).kidsCP := nilCell

	var ruleIndex : int
	enterRuleName (nodes (parsedCallNP).name, ruleIndex)

	nodes (parsedCallNP).count := ruleIndex  % for rule calls, represents called rule index

	var eaching := false

	bind var r to rules (ruleIndex)

	if r.called or (r.defined and not r.isExternalRule) then
	    % already defined or a successive call - must check parameter type
	    % consistency

	    if isCondition not= r.isCondition then
		error ("In TXL specification, rule '" + identTable (r.name) + "',\n" +
		    "  used as both replacement and 'where' condition", FATAL)
	    end if
    
	    % actuals parse like literals, even when they are not!
	    var literalsNP := trees.ruleCall_literalsNP (ruleCallNP)
	
	    if trees.plural_emptyP (literalsNP) then
		if r.localVars.nformals not= 0 then
		    error ("In TXL specification, rule '" + identTable (r.name) + "',\n" +
			"  number of parameters differs from definition or previous call", FATAL)
		end if

	    else
		newCell (nodes (parsedCallNP).kidsCP)
		var parsedActualsCP := nodes (parsedCallNP).kidsCP

		for actualCount : 1 .. r.localVars.nformals
		    var actualName := trees.literal_tokenT (trees.plural_firstNP (literalsNP))

		    % It might be an 'each' indicator
		    if actualName = eachT then
			literalsNP := trees.plural_restNP (literalsNP)

			if eaching or trees.plural_emptyP (literalsNP) then
			   error ("In TXL specification, rule '" + identTable (r.name) +
				"' used with empty or double 'each'", FATAL)
			end if

			eaching := true
		        actualName := trees.literal_tokenT (trees.plural_firstNP (literalsNP))
		    end if

		    newNode (cells (parsedActualsCP).firstNP)
		    nodes (cells (parsedActualsCP).firstNP).name := actualName

		    % We know the name, but is it a literal or a subsequent use?
		    var localIndex := 0
		    if not trees.isQuotedLiteral (trees.plural_firstNP (literalsNP)) then
			for i : 1 .. varsSoFar.nlocals
			    if varsSoFar.local (i).name = actualName then
				localIndex := i
				exit
			    end if
			end for
		    end if

		    if localIndex not= 0 then
			% it's a subsequent use of a variable
			% NOTE: it is statistically more efficient to count formals
			%   as references, and not count actuals, so we do not increment
			%   the reference count of varsSoFar.local (localIndex) here.
			% varsSoFar.local (localIndex).refs += 1
			%% BUT each's screw this up, so ...
			if eaching then
			    varsSoFar.local (localIndex).refs += 1
			end if

			nodes (cells (parsedActualsCP).firstNP).kind := kindT.subsequentUse
			nodes (cells (parsedActualsCP).firstNP).count := 
			    localIndex  % save looking for it later!
			% figure out the effective type
			var effectiveType := varsSoFar.local (localIndex).typename
			if eaching then
			    % we're in the scope of an 'each' - indicate with non-null kidsCP
			    newCell (nodes (cells (parsedActualsCP).firstNP).kidsCP)
			    if trees.isListOrRepeatType (effectiveType) then
				effectiveType := trees.listOrRepeatBaseType (effectiveType)
			    else
			       error ("In TXL specification, 'each' argument is not a 'repeat' " +
				    "or 'list' in call to rule '" + identTable (r.name) +
				    "'", FATAL)
			    end if
			else
			    % make sure we mark it as NOT an each!
			    nodes (cells (parsedActualsCP).firstNP).kidsCP := nilCell
			end if
			if r.localVars.local (actualCount).typename not= effectiveType then
			    error ( "In TXL specification, type of actual parameter '" +
				identTable (varsSoFar.local (localIndex).name) + "'\n" +
				"  in call to rule '" + identTable (r.name) +
				"' does not agree with definition or previous call", FATAL)
			end if
		    else
			% it's a literal 
			if not trees.isQuotedLiteral (trees.plural_firstNP (literalsNP)) then
			    error ("(Warning) In TXL specification, literal actual parameter '" +
				identTable (actualName) + "'\n  in call to rule '" + identTable (r.name) +
				"' is not quoted", WARNING)
			end if
			nodes (cells (parsedActualsCP).firstNP).kind :=
			    trees.literal_kindT (trees.plural_firstNP (literalsNP))
			if r.localVars.local (actualCount).typename not=
				trees.literalTypeName (nodes (cells (parsedActualsCP).firstNP).kind)
				then
			    error ( "In TXL specification, type of actual parameter " +
				"in call to rule '" + identTable (r.name) +
				"'\n  does not agree with definition or previous call", FATAL)
			end if
		    end if
	
		    cells (parsedActualsCP).restCP := nilCell
	
		    literalsNP := trees.plural_restNP (literalsNP)

		    if trees.plural_emptyP (literalsNP) then
			if actualCount < r.localVars.nformals then
			    error ("In TXL specification, rule '" + identTable (r.name) + "',\n" +
				"  number of parameters differs from definition or previous call",
				FATAL)
			end if
			exit
		    end if

		    newCell (cells (parsedActualsCP).restCP)
		    parsedActualsCP := cells (parsedActualsCP).restCP
		end for

		if not trees.plural_emptyP (literalsNP) then
		    error ("In TXL specification, rule '" + identTable (r.name) + "',\n" +
			"  number of parameters differs from definition or previous call", FATAL)
		end if
	    end if

	else
	    % first call - must enter parameter types and count
	    r.called := true
	    r.isCondition := isCondition
    
	    % actuals parse like literals, even when they are not!
	    var literalsNP := trees.ruleCall_literalsNP (ruleCallNP)
	    var actualCount := 0
	
	    if not trees.plural_emptyP (literalsNP) then
		newCell (nodes (parsedCallNP).kidsCP)
		var parsedActualsCP := nodes (parsedCallNP).kidsCP
		loop
		    actualCount += 1
		    var actualName := trees.literal_tokenT (trees.plural_firstNP (literalsNP))

		    % It might be an 'each' indicator
		    if actualName = eachT then
			literalsNP := trees.plural_restNP (literalsNP)

			if eaching or trees.plural_emptyP (literalsNP) then
			   error ("In TXL specification, rule '" + identTable (r.name) +
				"' used with empty or double 'each'", FATAL)
			end if

			eaching := true
		        actualName := trees.literal_tokenT (trees.plural_firstNP (literalsNP))
		    end if

		    newNode (cells (parsedActualsCP).firstNP)
		    nodes (cells (parsedActualsCP).firstNP).name := actualName

		    % We know the name, but is it a literal or a subsequent use?
		    var localIndex := 0
		    if not trees.isQuotedLiteral (trees.plural_firstNP (literalsNP)) then
			for i : 1 .. varsSoFar.nlocals
			    if varsSoFar.local (i).name = actualName then
				localIndex := i
				exit
			    end if
			end for
		    end if

		    if localIndex not= 0 then
			% it's a subsequent use of a variable
			% NOTE: it is statistically more efficient to count formals
			%   as references, and not count actuals, so we do not increment
			%   the reference count of varsSoFar.local (localIndex) here.
			% varsSoFar.local (localIndex).refs += 1
			%% BUT each's screw this up, so ...
			if eaching then
			    varsSoFar.local (localIndex).refs += 1
			end if
			nodes (cells (parsedActualsCP).firstNP).kind := kindT.subsequentUse
			nodes (cells (parsedActualsCP).firstNP).count := 
			    localIndex  % save looking for it later!
			% figure out the effective type
			var effectiveType := varsSoFar.local (localIndex).typename
			if eaching then
			    % we're in the scope of an 'each' - indicate with non-null kidsCP
			    newCell (nodes (cells (parsedActualsCP).firstNP).kidsCP)
			    if trees.isListOrRepeatType (effectiveType) then
				effectiveType := trees.listOrRepeatBaseType (effectiveType)
			    else
			       error ("In TXL specification, 'each' argument is not a 'repeat' " +
				    "or 'list' in call to rule '" + identTable (r.name) +
				    "'", FATAL)
			    end if
			else
			    % make sure we mark it as NOT an each!
			    nodes (cells (parsedActualsCP).firstNP).kidsCP := nilCell
			end if
			r.localVars.local (actualCount).typename := effectiveType
		    else
			% it's a literal 
			if not trees.isQuotedLiteral (trees.plural_firstNP (literalsNP)) then
			    error ("(Warning) In TXL specification, literal actual parameter '" +
				identTable (actualName) + "'\n  in call to rule '" + identTable (r.name) +
				"' is not quoted", WARNING)
			end if
			nodes (cells (parsedActualsCP).firstNP).kind :=
			    trees.literal_kindT (trees.plural_firstNP (literalsNP))
			r.localVars.local (actualCount).typename := 
			    trees.literalTypeName (nodes (cells (parsedActualsCP).firstNP).kind)
		    end if
	
		    cells (parsedActualsCP).restCP := nilCell
	
		    literalsNP := trees.plural_restNP (literalsNP)
		    exit when trees.plural_emptyP (literalsNP)
	
		    newCell (cells (parsedActualsCP).restCP)
		    parsedActualsCP := cells (parsedActualsCP).restCP
		end loop
	    end if

	    r.localVars.nformals := actualCount
	    r.localVars.nprelocals := actualCount
	    r.localVars.nlocals := actualCount
	end if

	r.called := true

    end buildRuleCall
    
    
    procedure checkVarOrExp (litsAndVarsAndExpsNP : nodePT,
	    var varsSoFar : localsListT, patternNP : nodePT, var parseNP : nodePT,
	    var isVarOrExp : boolean, var varOrExpMatches : boolean)
    
	if trees.plural_emptyP (litsAndVarsAndExpsNP) then
	    isVarOrExp := false
	    return
	end if
    
	var firstsKidNP := trees.kid1NP (trees.plural_firstNP (litsAndVarsAndExpsNP))
    
	if identTable (nodes (firstsKidNP).name) = "TXL_literal_" then
	    % May not be a literal: could be a subsequent use.
	    var localIndex := 0
	    for i : 1 .. varsSoFar.nlocals
		if varsSoFar.local (i).name = trees.literal_tokenT (firstsKidNP) then
		    localIndex := i
		    exit
		end if
	    end for
    
	    if localIndex = 0 then
		% Really was a literal after all.
		isVarOrExp := false
		return
	    end if

	    isVarOrExp := true
    
	    if trees.nodeIsTypeP (patternNP, varsSoFar.local (localIndex).typename) then
		varOrExpMatches := true
		newNode (parseNP)
		nodes (parseNP).kind := kindT.subsequentUse  % never has children
		nodes (parseNP).name := varsSoFar.local (localIndex).name
		nodes (parseNP).count := localIndex  % save looking for it later!
		% Subsequent uses do not count as references!
	    else
		varOrExpMatches := false
	    end if
    
	elsif identTable (nodes (firstsKidNP).name) = "TXL_firstTime_" then
	    isVarOrExp := true
	    var localIndex : int
	    enterLocalVar (varsSoFar, trees.firstTime_nameT (firstsKidNP), 
		trees.firstTime_typeT (firstsKidNP), localIndex)
    
	    % Check that the target production has been defined
	    var symbolIndex : int
	    findSymbol (varsSoFar.local (localIndex).typename, symbolIndex)
    
	    if trees.nodeIsTypeP (patternNP, varsSoFar.local (localIndex).typename) then
		varOrExpMatches := true
		newNode (parseNP)
		nodes (parseNP).kind := kindT.firstTime
		nodes (parseNP).name := varsSoFar.local (localIndex).name
		nodes (parseNP).count := localIndex  % save looking for it later!
	    else
		varOrExpMatches := false
	    end if
    
	elsif identTable (nodes (firstsKidNP).name) = "TXL_expression_" then
	    % in replacement id gets called expression.  May be literal.
	    const expressionName := trees.expression_baseT (firstsKidNP)
	    var localIndex := 0
	    for i : 1 .. varsSoFar.nlocals
		if varsSoFar.local (i).name = expressionName then
		    localIndex := i
		    exit
		end if
	    end for
    
	    if localIndex = 0 then
		% It is a literal
		isVarOrExp := false
		% Check for rule calls
		if not trees.plural_emptyP ( trees.expression_ruleCallsNP (firstsKidNP)) then
		    % Ooops - rule calls on a literal!
		    % in this case we force a syntax error by pretending
		    % it is a var that did not match.
		    isVarOrExp := true
		    varOrExpMatches := false
		end if
		return
	    end if

	    isVarOrExp := true
    
	    if trees.nodeIsTypeP (patternNP, varsSoFar.local (localIndex).typename) then
		varOrExpMatches := true
		newNode (parseNP)
		nodes (parseNP).kind := kindT.expression
		nodes (parseNP).name := trees.expression_baseT (firstsKidNP)
		nodes (parseNP).count := localIndex  % save looking for it later!
		nodes (parseNP).kidsCP := nilCell
		varsSoFar.local (localIndex).refs += 1
    
		% make children of type ruleCall
		var ruleCallsNP := trees.expression_ruleCallsNP (firstsKidNP)
    
		if not trees.plural_emptyP (ruleCallsNP) then
		    var parsedCallNP : nodePT
		    newCell (nodes (parseNP).kidsCP)
		    var lastKidCP : cellPT := nodes (parseNP).kidsCP
		    loop
			% loop through rule calls
			buildRuleCall (trees.plural_firstNP (ruleCallsNP),
			    varsSoFar, parsedCallNP, false)
			cells (lastKidCP).firstNP := parsedCallNP
    
			cells (lastKidCP).restCP := nilCell
    
			ruleCallsNP := trees.plural_restNP (ruleCallsNP)
			exit when trees.plural_emptyP (ruleCallsNP)
    
			newCell (cells (lastKidCP).restCP)
			lastKidCP := cells (lastKidCP).restCP
		    end loop
		end if
	    else
		varOrExpMatches := false
	    end if
    
	else
	    error ("(TXL internal error) Fatal TXL error in checkVarOrExp", FATAL)
	end if
    
    end checkVarOrExp
    
    
    forward procedure real_buildPatternOrReplacementTree (var varsSoFar : localsListT,
	patternNP : nodePT, var parseNP : nodePT)
    import (var nodes, var cells, newNode, newCell, var cellCount, var nodeCount,
	var buildScan, checkVarOrExp, 
	node_print_p, printSkippedToken, printParse, identTable, numberP, letterP,
	keyP, lowerP, upperP, digitP, var buildDepth, var buildStack, findLocalVar, var trees, 
	error, buildHandle)
    
    
    procedure buildPatternOrReplacementTree (var litsAndVarsAndExpsNP : nodePT,
	    var varsSoFar : localsListT, patternNP : nodePT, var parseNP : nodePT)

	% This procedure initializes our input stack for backup,
	% and then we call the real buildPatternOrReplacementTree.
    
	if parse_print_p or node_print_p then
	    put : 0, ""
	end if
    
	buildScan.initialize (litsAndVarsAndExpsNP)
	buildDepth := - 1
	parseNP := nilNode
    
	loop
	    real_buildPatternOrReplacementTree (varsSoFar, patternNP, parseNP)
	    exit when parseNP = nilNode or buildScan.nextToken = emptyT
	end loop
    
	litsAndVarsAndExpsNP := buildScan.restOfPattern 
	    % this is what my caller expects. It's bogus.
    
	if parse_print_p then
	    printParse (parseNP, 0, true)
	end if
    
    end buildPatternOrReplacementTree
    
    
    body procedure real_buildPatternOrReplacementTree % (var varsSoFar : localsListT, 
		% patternNP : nodePT, var parseNP : nodePT)

	%
	%   INPUT:
	%	varsSoFar - 		symbol table for rule so far
	%	patternNP - 		the target production 
	%	parseNP - 		either 1) nil, or
	%				       2) a previous parse yielding the target
	%
	%   OUTPUT:
	%	varsSoFar - 		updated symbol table for rule
	%	parseNP - 		either 1) a parse yielding the target production, or
	%				       2) nil
        %
        % If input parseNP is nil, then output parseNP is the first possible parse.
        % If input parseNP is a previous parse, the output parseNP is the next possible parse.
        % In either case, if the parse is not possible then output parseNP will be nil.
        %


	buildDepth += 1

	var isVarOrExp, varOrExpMatches := false

	if parseNP not= nilNode and
		(nodes (parseNP).kind = kindT.expression
		    or nodes (parseNP).kind = kindT.firstTime
		    or nodes (parseNP).kind = kindT.subsequentUse) then
	    % Retrying a variable match - 
	    %   what we do is look for a deeper match first, before coming back up.
	    % We can do that by fooling the parse algorithm into believing
	    % that we are trying the first match of a variable that doesn't match
	    % at this level.
	    parseNP := nilNode
	    buildScan.backup
	    isVarOrExp := true
	    varOrExpMatches := false
	end if


	if parseNP = nilNode then

	    % First attempt - not a retry

	    if node_print_p then
		put : 0, repeat (".", buildDepth), "?", identTable (nodes (patternNP).name) ..
		if buildScan.nextToken = emptyT then
		    put : 0, "EOF"
		else
		    put : 0, " " ..
		    printSkippedToken (buildScan.restOfPattern)
		end if
	    end if
    

	    % first see if we are dealing with a TXL variable or expression
	    if not isVarOrExp and buildScan.nextTokenKind = kindT.id then
		% maybe it's a variable or expression
		checkVarOrExp (buildScan.restOfPattern, varsSoFar, patternNP, parseNP, 
		    isVarOrExp, varOrExpMatches)
	    end if

    
	    if isVarOrExp and varOrExpMatches then

		% legit TXL var 
		buildScan.accept


	    elsif nodes (patternNP).kind = kindT.empty then

		% empty - first time we just match it.
		parseNP := patternNP


	    elsif nodes (patternNP).kind =  kindT.order then

		% update parse stack (for choose and order nodes only!)
		if buildDepth >= maxParseDepth then
		    error ("(Fatal) Maximum build depth exceeded", FATAL)
		end if

		buildStack (buildDepth) := nodes (patternNP).name

		% Check for infinite parse loop
		if (buildDepth - buildScan.depthOfLastAccept) > maxBlindParseDepth then
		    % we're deep - better check for an infinite loop!
		    for pd : buildScan.depthOfLastAccept + 1 .. buildDepth - 1
			if buildStack (pd) = nodes (patternNP).name then
			    % the never-ending story ...
			    if node_print_p then 
				put:0, "TXL Info: Gave up on infinite build loop on '",
				    identTable (nodes (patternNP).name),
				    "' with lookahead '", identTable (buildScan.nextToken), "'"
			    end if

			    parseNP := nilNode
			    buildDepth -= 1
			    return
			end if
		    end for
		end if

		% required for fancy parser speedup!
		assert trees.contiguousKids (patternNP)

		const productionKids := nodes (patternNP).count
		if productionKids = 0 then
		    error ("Fatal TXL error in build (productionKids = 0)", FATAL)
		end if

		% recover wasted space if we fail
		const oldCellCount := cellCount
		const oldNodeCount := nodeCount

		% this is the sneakiest optimization in history!
		% we pre-allocate ourselves a chunk of the cells array
		% and use it directly to avoid a local dynamic array here,
		% then link it up later if we succeed, otherwise free it.
		if cellCount + productionKids > maxCells then
		    error ("(Fatal) Out of cell space - " +
			intstr (maxCells, 1) + " cells have been allocated.", FATAL)
		end if

		% don't try this at home, kids!
		const baseParseKidCP := cellCount
		cellCount += productionKids

		% Now we parse!
		% since they are contiguous, we can just run up and down
		% the production kid list directly!
		const baseProductionKidCP := nodes (patternNP).kidsCP - 1
		% so parse knows it's the first try
		cells (baseParseKidCP + 1).firstNP := nilNode  

		var register kid := 1
		var retry := false
		loop
		    const oldBuildHandle := buildHandle

		    real_buildPatternOrReplacementTree (varsSoFar,
			cells (baseProductionKidCP + kid).firstNP, 
			     cells (baseParseKidCP + kid).firstNP)

		    if cells (baseParseKidCP + kid).firstNP = nilNode then
			% retry another match of the previous kid
			kid -= 1
			exit when kid = 0
			retry := true
		    elsif retry => oldBuildHandle not= buildHandle then
			% go on to the next one
			kid += 1
			exit when kid = productionKids + 1
			retry := false
			cells (baseParseKidCP + kid).firstNP := nilNode  % first try
		    % else
			% re-parses of an embedded kid that yield the 
			% same lookahead are uninteresting since the 
			% rest will fail in the same way!
			%  - so ask for another try of the same kid
		    end if
		end loop

		% we fail if we're at the left, 
		% succeed if we made it all the way to the right.
		% of course, now we need to build the tree if we succeeded.
		if kid not= 0 then
		    % build the parent
		    newNode (parseNP)
		    nodes (parseNP) := nodes (patternNP) % sets kind, name and count

		    % link in the kids we already sneakily allocated 
		    % and filled in directly back there
		    nodes (parseNP).kidsCP := baseParseKidCP + 1

		    for k : 1 .. productionKids - 1
			const parseKidCP := baseParseKidCP + k
			cells (parseKidCP).restCP := parseKidCP + 1
		    end for

		    cells (baseParseKidCP + productionKids).restCP := nilCell

		else
		    parseNP := nilNode
		    % recover wasted space
		    nodeCount := oldNodeCount
		    cellCount := oldCellCount
		end if


	    elsif nodes (patternNP).kind =  kindT.choose then

		% update parse stack (for choose and order nodes only!)
		if buildDepth >= maxParseDepth then
		    error ("(Fatal) Maximum parse depth exceeded (build)", FATAL)
		end if

		buildStack (buildDepth) := nodes (patternNP).name

		% Check for infinite parse loop
		if (buildDepth - buildScan.depthOfLastAccept) > maxBlindParseDepth then
		    % we're deep - better check for an infinite loop!
		    for pd : buildScan.depthOfLastAccept + 1 .. buildDepth - 1
			if buildStack (pd) = nodes (patternNP).name then
			    % the never-ending story ...
			    if node_print_p then 
				put:0, "TXL Info: Gave up on infinite build loop on '",
				    identTable (nodes (patternNP).name),
				    "' with lookahead '", identTable (buildScan.nextToken), "'"
			    end if

			    parseNP := nilNode
			    buildDepth -= 1
			    return
			end if
		    end for
		end if

		% recover wasted space if we fail
		const oldCellCount := cellCount
		const oldNodeCount := nodeCount

		var patternKidsCP := nodes (patternNP).kidsCP
		const productionKids := nodes (patternNP).count
		var parseKidNP : nodePT := nilNode

		assert parseNP = nilNode

		% try each alternative until we get a match
		for kid : 1 .. productionKids

		    real_buildPatternOrReplacementTree (varsSoFar,
		    	cells (patternKidsCP).firstNP, parseKidNP)

		    if parseKidNP not= nilNode then
			% one success is all we need
			newNode (parseNP)
			nodes (parseNP) := nodes (patternNP) % sets kind and name
			% encode choice we made in the parse node, in case we must retry
			nodes (parseNP).count := kid
			newCell (nodes (parseNP).kidsCP)
			cells (nodes (parseNP).kidsCP).firstNP := parseKidNP
			cells (nodes (parseNP).kidsCP).restCP := nilCell
			exit
		    end if

		    % try the next alternative
		    patternKidsCP := cells (patternKidsCP).restCP

		    % subsequent tries must be with nil nodes!
		    parseKidNP := nilNode
		end for

		if parseNP = nilNode then
		    % recover wasted space
		    nodeCount := oldNodeCount
		    cellCount := oldCellCount
		end if


	    elsif not isVarOrExp then

		% Terminals

		case nodes (patternNP).kind of

		    label kindT.literal :
			% don't care what it is, but it must match exactly
			assert parseNP = nilNode
			if buildScan.nextToken = nodes (patternNP).name then
			    %  accept
			    newNode (parseNP)
			    nodes (parseNP) := nodes (patternNP)
			    buildScan.accept
			end if

		    label kindT.stringlit :
			assert parseNP = nilNode
			if buildScan.nextTokenKind = kindT.stringlit then
			    %  accept
			    newNode (parseNP)
			    nodes (parseNP) := nodes (patternNP)
			    nodes (parseNP).name := buildScan.nextToken 
			    buildScan.accept
			end if

		    label kindT.charlit :
			assert parseNP = nilNode
			if buildScan.nextTokenKind = kindT.charlit then
			    %  accept
			    newNode (parseNP)
			    nodes (parseNP) := nodes (patternNP)
			    nodes (parseNP).name := buildScan.nextToken 
			    buildScan.accept
			end if

		    label kindT.number :
			assert parseNP = nilNode
			if buildScan.nextTokenKind = kindT.number then
			    %  accept
			    newNode (parseNP)
			    nodes (parseNP) := nodes (patternNP)
			    nodes (parseNP).name := buildScan.nextToken 
			    buildScan.accept
			end if

		    label kindT.floatnumber :
			assert parseNP = nilNode
			const tokenText := identTable (buildScan.nextToken)
			if buildScan.nextTokenKind = kindT.number 
				and (index (tokenText, "e") not= 0 
				    or index (tokenText, "E") not= 0) then
			    %  accept
			    newNode (parseNP)
			    nodes (parseNP) := nodes (patternNP)
			    nodes (parseNP).name := buildScan.nextToken 
			    buildScan.accept
			end if

		    label kindT.decimalnumber :
			assert parseNP = nilNode
			const tokenText := identTable (buildScan.nextToken)
			if buildScan.nextTokenKind = kindT.number 
				and index (tokenText, ".") not= 0 then 
			    %  accept
			    newNode (parseNP)
			    nodes (parseNP) := nodes (patternNP)
			    nodes (parseNP).name := buildScan.nextToken 
			    buildScan.accept
			end if

		    label kindT.integernumber :
			assert parseNP = nilNode
			if buildScan.nextTokenKind = kindT.number then
			    const tokenText := identTable (buildScan.nextToken)
			    const textLength := length (tokenText)
			    for d : 1 .. textLength
				const nextchar : char := tokenText (d)
				exit when not digitP (nextchar)
				if d = textLength then
				    %  accept
				    newNode (parseNP)
				    nodes (parseNP) := nodes (patternNP)
				    nodes (parseNP).name := buildScan.nextToken 
				    buildScan.accept
				end if
			    end for
			end if

		    label kindT.id :
			% any id not a keyword
			assert parseNP = nilNode
			if buildScan.nextTokenKind = kindT.id then
			    %  accept
			    newNode (parseNP)
			    nodes (parseNP) := nodes (patternNP)
			    nodes (parseNP).name := buildScan.nextToken 
			    buildScan.accept
			end if

		    label kindT.upperlowerid :
			assert parseNP = nilNode
			const firstchar : char :=
				identTable (buildScan.nextToken) (1)
			if buildScan.nextTokenKind = kindT.id 
				and upperP (firstchar) then
			    %  accept
			    newNode (parseNP)
			    nodes (parseNP) := nodes (patternNP)
			    nodes (parseNP).name := buildScan.nextToken 
			    buildScan.accept
			end if

		    label kindT.lowerupperid :
			assert parseNP = nilNode
			const firstchar : char :=
				identTable (buildScan.nextToken) (1)
			if buildScan.nextTokenKind = kindT.id 
				and lowerP (firstchar) then
			    %  accept
			    newNode (parseNP)
			    nodes (parseNP) := nodes (patternNP)
			    nodes (parseNP).name := buildScan.nextToken 
			    buildScan.accept
			end if

		    label kindT.upperid :
			assert parseNP = nilNode
			if buildScan.nextTokenKind = kindT.id then
			    const tokenText := identTable (buildScan.nextToken)
			    const textLength := length (tokenText)
			    for d : 1 .. textLength
				const nextchar : char := tokenText (d)
				exit when not upperP (nextchar)
				if d = textLength then
				    %  accept
				    newNode (parseNP)
				    nodes (parseNP) := nodes (patternNP)
				    nodes (parseNP).name := buildScan.nextToken 
				    buildScan.accept
				end if
			    end for
			end if

		    label kindT.lowerid :
			assert parseNP = nilNode
			if buildScan.nextTokenKind = kindT.id then
			    const tokenText := identTable (buildScan.nextToken)
			    const textLength := length (tokenText)
			    for d : 1 .. textLength
				const nextchar : char := tokenText (d)
				exit when not lowerP (nextchar)
				if d = textLength then
				    %  accept
				    newNode (parseNP)
				    nodes (parseNP) := nodes (patternNP)
				    nodes (parseNP).name := buildScan.nextToken 
				    buildScan.accept
				end if
			    end for
			end if

		    label kindT.token :
			% generic token - used only for TXL source itself 
			% anything is ok unless it's a key symbol
			% whatever it is, it retains its own kind!
			assert parseNP = nilNode
			const tokenKind := buildScan.nextTokenKind
			if tokenKind not= kindT.key and tokenKind not= kindT.empty then
			    %  accept
			    newNode (parseNP)
			    nodes (parseNP) := nodes (patternNP)
			    nodes (parseNP).kind := tokenKind
			    nodes (parseNP).name := buildScan.nextToken 
			    buildScan.accept
			end if

		    label kindT.key :
			% generic keyword - used only for TXL source itself 
			assert parseNP = nilNode
			if buildScan.nextTokenKind = kindT.key then
			    newNode (parseNP)
			    nodes (parseNP) := nodes (patternNP)
			    nodes (parseNP).name := buildScan.nextToken 
			    buildScan.accept
			end if

		    label kindT.empty, kindT.order, kindT.choose,
			    kindT.firstTime, kindT.subsequentUse, kindT.expression,
			    kindT.ruleCall, kindT.undefined :
			error ("Fatal TXL error in build", FATAL)
		end case


	    elsif isVarOrExp and not varOrExpMatches then

		% it's a var ref for sure, but it doesn't fit here!
		parseNP := nilNode

	    end if



	else

	    % Backup

	    if node_print_p then
		put : 0, repeat (".", buildDepth), "?", identTable (nodes (patternNP).name) ..
		put : 0, " <-*-> " ..
		if buildScan.nextToken = emptyT then
		    put : 0, " EOF"
		else
		    put : 0, " ", identTable (buildScan.nextToken)
		end if
		put : 0, "--> RETRY IN PROGRESS.  Parse Tree passed to me was..."
		printParse (parseNP, 0, true)
	    end if

	    % No infinite loop check since this is a retry!

	    case nodes (patternNP).kind of

		label kindT.empty :

		    % backing up match of empty!!
		    parseNP := nilNode


		label kindT.order :

		    % Retrying an order node

		    assert nodes (parseNP).kind = kindT.order

		    % update parse stack (for choose and order nodes only!)
		    if buildDepth >= maxParseDepth then
			error ("(Fatal) Maximum parse depth exceeded (build)", FATAL)
		    end if

		    buildStack (buildDepth) := nodes (patternNP).name

		    % recover wasted space if we fail
		    const oldCellCount := cellCount
		    const oldNodeCount := nodeCount

		    % required for fancy parser speedup!
		    assert trees.contiguousKids (patternNP)

		    const productionKids := nodes (patternNP).count

		    % Now we parse!
		    % Undo previous matches in reverse order on retry.
		    % since kids of productions are contiguous cells, we
		    % can simply walk up and down them directly!
		    const baseProductionKidCP := nodes (patternNP).kidsCP - 1

		    % since the kid cells of the previous parse were also allocated
		    % contiguously, we can use them in place too!
		    const baseParseKidCP := nodes (parseNP).kidsCP - 1

		    var register kid := productionKids
		    var retry := true
		    loop
			const oldBuildHandle := buildHandle

			real_buildPatternOrReplacementTree (varsSoFar,
			    cells (baseProductionKidCP + kid).firstNP, 
				 cells (baseParseKidCP + kid).firstNP)

			if cells (baseParseKidCP + kid).firstNP = nilNode then
			    kid -= 1
			    exit when kid = 0
			    retry := true
			elsif retry => buildHandle not= oldBuildHandle  then
			    kid += 1
			    exit when kid = productionKids + 1
			    retry := false
			    cells (baseParseKidCP + kid).firstNP := nilNode
			% else
			    % re-parses of an embedded kid that yield the 
			    % same lookahead are uninteresting since the 
			    % rest will fail in the same way!
			    %  - so ask for another try of the same kid
			end if
		    end loop

		    % we fail if we're at the left, 
		    % succeed if we made it all the way to the right
		    % all kids are already in place!

		    if kid = 0 then
			parseNP := nilNode
			% recover wasted space
			nodeCount := oldNodeCount
			cellCount := oldCellCount
		    end if


		label kindT.choose :

		    % Retrying a choose node

		    assert nodes (parseNP).kind = kindT.choose

		    % update parse stack (for choose and order nodes only!)
		    if buildDepth >= maxParseDepth then
			error ("(Fatal) Maximum parse depth exceeded", FATAL)
		    end if

		    buildStack (buildDepth) := nodes (patternNP).name

		    % recover wasted space if we fail
		    const oldCellCount := cellCount
		    const oldNodeCount := nodeCount

		    const productionKids := nodes (patternNP).count

		    % nodes (parseNP).count encodes the number of the choice 
		    % we used last time.
		    % first we give that one a chance to retry, 
		    % then try the other alternatives if it fails.
		    const kidLastTime := nodes (parseNP).count

		    % first time through we re-try the last match 
		    var parseKidNP : nodePT := cells (nodes (parseNP).kidsCP).firstNP
		    % since kids are kept contiguous, we can address the corresponding
		    % production kid directly!
		    var patternKidsCP := nodes (patternNP).kidsCP + kidLastTime - 1

		    % OK -- we loop until we get a new match!
		    for kid : kidLastTime .. productionKids

			real_buildPatternOrReplacementTree (varsSoFar,
			    cells (patternKidsCP).firstNP, parseKidNP)

			if parseKidNP not= nilNode then
			    % one success is all we need
			    % we re-use the node and cell structure we allocated 
			    % on the first try
			    cells (nodes (parseNP).kidsCP).firstNP := parseKidNP
			    % encode choice we made in the parse node, 
			    % in case we must retry again
			    nodes (parseNP).count := kid
			    exit
			end if

			% try the next alternative
			patternKidsCP := cells (patternKidsCP).restCP

			% subsequent tries must be with nil nodes!
			parseKidNP := nilNode
		    end for

		    if parseKidNP = nilNode then
			parseNP := nilNode
			% recover wasted space
			nodeCount := oldNodeCount
			cellCount := oldCellCount
		    end if

		label kindT.literal, kindT.stringlit, kindT.charlit, kindT.token,
			kindT.id, kindT.upperlowerid, kindT.upperid, 
			kindT.lowerupperid, kindT.lowerid, kindT.number,
			kindT.floatnumber, kindT.decimalnumber, kindT.integernumber,
			kindT.key :
		    % Retrying a terminal - only thing left to do is back up!
		    parseNP := nilNode
		    buildScan.backup

		label kindT.firstTime, kindT.subsequentUse, kindT.expression,
			kindT.ruleCall, kindT.undefined :
		    error ("Fatal TXL error in build", FATAL)
	    end case

	end if

	if node_print_p then
	    if parseNP = nilNode then
		put : 0, repeat (".", buildDepth), "#", identTable (nodes (patternNP).name) ..
		if buildScan.nextToken = emptyT then
		    put : 0, " EOF"
		else
		    put : 0, " " ..
		    printSkippedToken (buildScan.restOfPattern)
		end if
	    else
		put : 0, repeat (".", buildDepth), "!", identTable (nodes (patternNP).name)
	    end if
	end if

	buildDepth -= 1

    end real_buildPatternOrReplacementTree


    procedure buildPatternOrReplacement (ruleName : tokenT,
	    goalName : tokenT,
	    partBeingBuilt : string,
	    patternOrReplacementNP : nodePT,
	    var parseNP : nodePT,
	    var varsSoFar : localsListT)

	% This is designed to work for both patterns and replacements
	var litsAndVarsAndExpsNP :nodePT :=
	    trees.patternOrReplacement_litsAndVarsAndExpsNP (patternOrReplacementNP)
	var symbolIndex : int

	findSymbol (goalName, symbolIndex)

	const goalNP := symbolTable (symbolIndex)

	buildPatternOrReplacementTree (litsAndVarsAndExpsNP, varsSoFar,
	    goalNP, parseNP)

	if parseNP = nilNode or not trees.plural_emptyP (litsAndVarsAndExpsNP) then
	    var failLitsAndVarsAndExpsNP := buildNodes (failBuildHandle)
	    if trees.plural_emptyP (failLitsAndVarsAndExpsNP) then
		failLitsAndVarsAndExpsNP := buildNodes (1)
	    end if

	    patternError (failLitsAndVarsAndExpsNP, partBeingBuilt +
		" of rule " + identTable (ruleName) + "\n  with goal production " +
		identTable (goalName))
	end if

    end buildPatternOrReplacement


    procedure processConstruct (ruleNameT : tokenT,
	    constructNP : nodePT,
	    var part : partDescriptor,
	    var localVars : localsListT)

	part.kind := partKind.construct
	const nameT := trees.construct_varNameT (constructNP)
	part.name := nameT

	% lookup name in VarsSo far.  If it's there, then it's an error
	var localIndex : int
	lookupLocalVar (localVars, nameT, localIndex)
	if localIndex not= 0 then
	    error ("In TXL specification, rule definition '" + identTable (ruleNameT) + 
		"',\n  construct variable '" + identTable (nameT) + 
		"' has already been defined", FATAL)
	end if

	const targetT := trees.construct_targetT (constructNP)
	part.target := targetT

	% enter variable in LocalVars
	enterLocalVar (localVars, nameT, targetT, localIndex)
	part.nameRef := localIndex

	const replacementNP := trees.construct_replacementNP (constructNP)

	buildPatternOrReplacement (ruleNameT, targetT, 
	    "replacement of construct " + identTable (nameT),
	    replacementNP, part.replacementNP, localVars)

    end processConstruct


    procedure processDeconstruct (ruleNameT : tokenT,
	    deconstructNP : nodePT,
	    var part : partDescriptor,
	    var localVars : localsListT)

	part.kind := partKind.deconstruct
	const nameT := trees.deconstruct_varNameT (deconstructNP)
	part.name := nameT

	% lookup name in varsSoFar - it must be there if we're deconstructing it!
	var localIndex : int
	findLocalVar (localVars, nameT, localIndex)

	localVars.local (localIndex).refs += 1	% deconstruct itself is a use of it!
	part.nameRef := localIndex

	const targetT := localVars.local (localIndex).typename 
	part.target := targetT

	const patternNP := trees.deconstruct_patternNP (deconstructNP)

	buildPatternOrReplacement (ruleNameT, targetT,
	    "pattern of deconstruct " + identTable (nameT),
	    patternNP, part.patternNP, localVars)

    end processDeconstruct


    procedure processCondition (ruleNameT : tokenT, conditionNP : nodePT,
	    var part : partDescriptor, var localVars : localsListT)
	% condition ::= 'condition [expression]
	const expressionNP := trees.condition_expressionNP (conditionNP)

	part.kind := partKind.cond
	const nameT := trees.expression_baseT (expressionNP)
	part.name := nameT

	% lookup name in varsSoFar - It must be there if we have a condition on it!
	var localIndex : int
	findLocalVar (localVars, nameT, localIndex)

	% condition (where) itself is a use of it!
	localVars.local (localIndex).refs += 1

	part.nameRef := localIndex

	const targetT := localVars.local (localIndex).typename 
	part.target := targetT

	% OK, now we cheat like hell.  What we are going to do is to imbed
	% the expression in an expsAndLitsAndVars tree so we can call
	% buildPatternOrReplacement

	var parseNP : nodePT
	newNode (parseNP)
	nodes (parseNP).kind := kindT.expression
	nodes (parseNP).name := nameT
	nodes (parseNP).count := localIndex  % save looking for it later!
	nodes (parseNP).kidsCP := nilCell

	% make kids of rule call
	var ruleCallsNP := trees.expression_ruleCallsNP (expressionNP)
		assert not trees.plural_emptyP (ruleCallsNP)
	var parsedCallNP : nodePT
	newCell (nodes (parseNP).kidsCP)
	var lastKidCP : cellPT := nodes (parseNP).kidsCP
	loop
	    buildRuleCall (trees.plural_firstNP (ruleCallsNP), localVars, 
		parsedCallNP, true)
	    cells (lastKidCP).firstNP := parsedCallNP

	    cells (lastKidCP).restCP := nilCell

	    ruleCallsNP := trees.plural_restNP (ruleCallsNP)
	    exit when trees.plural_emptyP (ruleCallsNP)

	    newCell (cells (lastKidCP).restCP)
	    lastKidCP := cells (lastKidCP).restCP
	end loop

	part.replacementNP := parseNP

    end processCondition


    procedure enterRuleFormals (ruleIndex : int, arg_formalsNP : nodePT)

	bind var r to rules (ruleIndex)
	var formalsNP := arg_formalsNP

	if r.called then
	    % rule has been previously called; back-check the parameter types
	    for formalCount : 1 .. r.localVars.nformals
		if trees.plural_emptyP (formalsNP) then
		    error ("In TXL specification, rule definition '" + identTable (r.name) + 
			"',\n  number of parameters does not agree with previous call", FATAL)
		end if
		bind var formal to r.localVars.local (formalCount), rulename to r.name
		formal.name := trees.formal_nameT (trees.plural_firstNP (formalsNP))

		const declaredFormalType := 
		    trees.formal_typeT (trees.plural_firstNP (formalsNP))

		% Check that the declared target production has been defined
		var symbolIndex : int
		findSymbol (declaredFormalType, symbolIndex)
    
		if formal.typename not= declaredFormalType then
		    error ("In TXL specification, rule definition '" + identTable (rulename) + 
			"',\n  type of formal parameter '" + identTable (formal.name) +
			"' does not agree with previous call", FATAL)
		end if

		% NOTE: It is statistically more efficient to count formals as references,
		%   and not count actuals, so we start each formal with one reference here.
		formal.refs := 1
		formalsNP := trees.plural_restNP (formalsNP)
	    end for

	    if not trees.plural_emptyP (formalsNP) then
		error ("In TXL specification, rule definition '" + identTable (r.name) + 
		    "',\n  number of parameters does not agree with previous call", FATAL)
	    end if

	    r.localVars.nprelocals := r.localVars.nformals
	    r.localVars.nlocals := r.localVars.nformals

	else
	    % rule has not been called yet - nothing to check against
	    var formalCount := 0

	    loop
		exit when trees.plural_emptyP (formalsNP)
		formalCount += 1
		bind var formal to r.localVars.local (formalCount)
		formal.name := trees.formal_nameT (trees.plural_firstNP (formalsNP))
		formal.typename := trees.formal_typeT (trees.plural_firstNP (formalsNP))

		% Check that the declared target production has been defined
		var symbolIndex : int
		findSymbol (formal.typename, symbolIndex)

		% NOTE: It is statistically more efficient to count formals as references,
		%   and not count actuals, so we start each formal with one reference here.
		formal.refs := 1
		formalsNP := trees.plural_restNP (formalsNP)
	    end loop

	    r.localVars.nformals := formalCount
	    r.localVars.nprelocals := formalCount
	    r.localVars.nlocals := formalCount
	end if
    end enterRuleFormals


    procedure enterRuleBody (ruleIndex : int, ruleNP : nodePT)

	bind var r to rules (ruleIndex)

	% enter target name and kind
	r.targetName := trees.rule_targetT (ruleNP)

	var symbolIndex : int
	findSymbol (r.targetName, symbolIndex)

	r.targetKind := nodes (symbolTable (symbolIndex)).kind

	% process prePattern
	var prePatternCount := 0
	var prePatternNP := trees.rule_prePatternNP (ruleNP)
	loop
	    exit when trees.plural_emptyP (prePatternNP) % is this right?

	    prePatternCount += 1
	    const partNP := trees.kid1NP (trees.kid1NP (trees.kid1NP (prePatternNP)))
	    const partName := identTable (nodes (partNP).name)

	    if partName = "TXL_conditionPart_" then
		processCondition (trees.rule_nameT (ruleNP), partNP,
		    r.prePattern (prePatternCount), r.localVars)

	    elsif partName = "TXL_constructPart_" then
		processConstruct (trees.rule_nameT (ruleNP), partNP,
		    r.prePattern (prePatternCount), r.localVars)

	    else
		assert partName = "TXL_deconstructPart_"
		processDeconstruct (trees.rule_nameT (ruleNP), partNP,
		    r.prePattern (prePatternCount), r.localVars)
	    end if

	    prePatternNP := trees.plural_restNP (prePatternNP)
	end loop
	r.prePatternCount := prePatternCount
	r.localVars.nprelocals := r.localVars.nlocals

	% process skipping
	const optSkippingNP := trees.rule_optSkippingNP (ruleNP)

	if trees.plural_emptyP (optSkippingNP) then
	    r.skipName := NOT_FOUND
	else
	    r.skipName := trees.optSkipping_nameT (optSkippingNP)
	end if

	% process pattern
	buildPatternOrReplacement (trees.rule_nameT (ruleNP), trees.rule_targetT (ruleNP),
	    "pattern", trees.rule_patternNP (ruleNP), r.patternNP, r.localVars)

	% process postPattern
	var postPatternCount := 0
	var postConstructCount := 0
	var postPatternNP := trees.rule_postPatternNP (ruleNP)
	loop
	    exit when trees.plural_emptyP (postPatternNP) % is this right?

	    postPatternCount += 1
	    const partNP := trees.kid1NP (trees.kid1NP (trees.kid1NP (postPatternNP)))
	    const partName := identTable (nodes (partNP).name)

	    if partName = "TXL_conditionPart_" then
		% if we've already done a post construct, it may be discarded
		% when this deconstruct fails, so % mark this rule as 
		% construct-dangerous ...
		r.hasPostCondition := postConstructCount > 0
		processCondition (trees.rule_nameT (ruleNP), partNP,
		    r.postPattern (postPatternCount), r.localVars)

	    elsif partName = "TXL_constructPart_" then
		postConstructCount += 1
		processConstruct (trees.rule_nameT (ruleNP), partNP,
		    r.postPattern (postPatternCount), r.localVars)

	    else
		assert partName = "TXL_deconstructPart_"
		% if we've already done a post construct, it may be discarded
		% when this deconstruct fails, so mark this rule as 
		% construct-dangerous ...
		r.hasPostCondition := postConstructCount > 0
		processDeconstruct (trees.rule_nameT (ruleNP), partNP,
		    r.postPattern (postPatternCount), r.localVars)
	    end if

	    postPatternNP := trees.plural_restNP (postPatternNP)
	end loop
	r.postPatternCount := postPatternCount

	% process replacement
	const optByReplacementNP := trees.rule_optByReplacementNP (ruleNP)

	if identTable (trees.rule_replaceOrMatchT (ruleNP)) = "replace" then
	    if trees.plural_emptyP (optByReplacementNP) then
		error ("In TXL specification, rule '" + identTable (trees.rule_nameT (ruleNP)) + 
		    "',\n  'replace' rule must have a replacement", FATAL)
	    else
		buildPatternOrReplacement (trees.rule_nameT (ruleNP), trees.rule_targetT (ruleNP),
		    "replacement", trees.optByReplacement_replacementNP (optByReplacementNP), 
		    r.replacementNP, r.localVars)
	    end if
	else
	    assert identTable (trees.rule_replaceOrMatchT (ruleNP)) = "match"
	    if not trees.plural_emptyP (optByReplacementNP) then
		error ("In TXL specification, rule '" + identTable (trees.rule_nameT (ruleNP)) + 
		    "',\n  'match' rule cannot have a replacement", FATAL)
	    end if
	    r.replacementNP := nilNode
	end if

    end enterRuleBody


    procedure checkUserDefinedRuleName (name : tokenT)
	if index (identTable (name), "list_") = 1 or
		index (identTable (name), "repeat_") = 1 or
		index (identTable (name), "opt_") = 1 or 
		index (identTable (name), "lit_") = 1 then 
	    error ("Illegal rule name " + identTable (name) + " in TXL specification\n" +
		"  ('list_', 'repeat_' and 'opt_' prefixes are reserved for TXL internal use)", 
		FATAL)
	end if
    end checkUserDefinedRuleName


    procedure processRule (ruleNP : nodePT)
	const ruleName := trees.rule_nameT (ruleNP)
	checkUserDefinedRuleName (ruleName)
	var ruleIndex : int
	enterRuleName (ruleName, ruleIndex)
	if rules (ruleIndex).defined then
	    error ("In TXL specification, rule '" + identTable (rules (ruleIndex).name) + 
		"', has been previously defined", FATAL)
	end if
	enterRuleFormals (ruleIndex, trees.rule_formalsNP (ruleNP))
	rules (ruleIndex).defined := true
	rules (ruleIndex).isFunctionRule := false
	rules (ruleIndex).isExternalRule := false
	enterRuleBody (ruleIndex, ruleNP)
	if rules (ruleIndex).called and rules (ruleIndex).isCondition 
		and rules (ruleIndex).replacementNP not= nilNode then
	    error ("In TXL specification, 'replace' rule '" + 
		identTable (rules (ruleIndex).name) + "',\n" +
		"  previously used as 'where' condition", FATAL)
	else
	    rules (ruleIndex).isCondition := 
		rules (ruleIndex).replacementNP = nilNode
	end if
    end processRule


    procedure processFunction (ruleNP : nodePT)
	const ruleName := trees.rule_nameT (ruleNP)
	checkUserDefinedRuleName (ruleName)
	var ruleIndex : int
	enterRuleName (ruleName, ruleIndex)
	if rules (ruleIndex).defined then
	    error ("In TXL specification, function '" + identTable (rules (ruleIndex).name) + 
		"', has been previously defined", FATAL)
	end if
	enterRuleFormals (ruleIndex, trees.rule_formalsNP (ruleNP))
	rules (ruleIndex).defined := true
	rules (ruleIndex).isFunctionRule := true
	rules (ruleIndex).isExternalRule := false
	enterRuleBody (ruleIndex, ruleNP)
	if rules (ruleIndex).called and rules (ruleIndex).isCondition 
		and rules (ruleIndex).replacementNP not= nilNode then
	    error ("In TXL specification, 'replace' rule '" + 
		identTable (rules (ruleIndex).name) + "',\n" +
		"  previously used as 'where' condition", FATAL)
	else
	    rules (ruleIndex).isCondition := 
		rules (ruleIndex).replacementNP = nilNode
	end if
    end processFunction


    procedure processExternal (extNP : nodePT)
	const ruleName := trees.external_nameT (extNP)
	checkUserDefinedRuleName (ruleName)
	var ruleIndex : int
	enterRuleName (ruleName, ruleIndex)
	if rules (ruleIndex).defined then
	    error ("In TXL specification, external rule/function '" + 
		identTable (rules (ruleIndex).name) + "', has been previously defined", FATAL)
	end if
	enterRuleFormals (ruleIndex, trees.external_formalsNP (extNP))

	bind var r to rules (ruleIndex)
	r.defined := true
	r.targetName := NOT_FOUND
	r.targetKind := kindT.undefined
	r.skipName := NOT_FOUND
	r.prePatternCount := 0
	r.patternNP := nilNode
	r.postPatternCount := 0
	r.replacementNP := nilNode
	r.isFunctionRule := false
	r.isExternalRule := true
	r.isCondition := false
    end processExternal


    body procedure makeRuleTable %(txlParseTreeNP : nodePT)

	assert ruleCount = numPredefinedRules  % predefined rules 'not' and 'fail' initialized

	% initialize pre-hashed names
	ident.install ("each", eachT)

	% enter mainRule in table
	var mainRuleName : tokenT
	ident.install ("mainRule", mainRuleName)

	var mainRuleIndex : int
	enterRuleName (mainRuleName, mainRuleIndex)
	assert mainRuleIndex = numPredefinedRules + 1

	% now process rule definitions
	var statementsLeftNP := trees.program_statementsNP (txlParseTreeNP)

	loop
	    exit when trees.plural_emptyP (statementsLeftNP)

	    const statementNP :=
		trees.statement_keyDefRuleNP (trees.plural_firstNP (statementsLeftNP))
	    const statementKind := identTable (nodes (statementNP).name)

	    if statementKind = "TXL_ruleStatement_" then
		processRule (statementNP)
	    elsif statementKind = "TXL_functionStatement_" then
		processFunction (statementNP)
	    elsif statementKind = "TXL_externalStatement_" then
		processExternal (statementNP)
	    else
		assert statementKind = "TXL_keysStatement_" or
		    statementKind = "TXL_defineStatement_"
		% handled previously when creating the object language
		% grammar tree, so ignore now
	    end if

	    statementsLeftNP := trees.plural_restNP (statementsLeftNP)
	end loop

	% check that all rules have been defined
	var undefinedRules := false

	for r : 1 .. ruleCount
	    if not rules (r).defined then
		error ("In TXL specification, rule '" + identTable (rules (r).name) +
		    "' has not been defined", WARNING)
		undefinedRules := true
	    end if
	end for

	if undefinedRules then
	    quit
	end if

    end makeRuleTable

end ruleCompiler
%#end if
%child "externals.ch"
% TXL v5.3 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

%parent "txl.t"

stub module externalRules
    import (identTable, var nodes, newNode, var cells, var trees, 
	var ident, error, printParse, printLeaves)
    export (applyRule1)

    procedure applyRule1 (ruleName : tokenT, var scope : nodePT,
        localVars : localsListT, var success : boolean)
end externalRules


body module externalRules

    function numberValue (tree : nodePT) : real
        result strreal (identTable (nodes (tree).name))
    end numberValue

    function idString (tree : nodePT) : tokenValueT
        result identTable (nodes (tree).name)
    end idString

    procedure setNumberValue (var tree : nodePT, value : real)
        var val : tokenValueT := realstr (value, 0)
        var newToken : tokenT
        ident.install (val, newToken)
        nodes (tree).name := newToken
    end setNumberValue

    procedure setIdValue (var tree : nodePT, newName : tokenValueT)
        var newToken : tokenT
        ident.install (newName, newToken)
        nodes (tree).name := newToken
    end setIdValue

    function literalString (tree : nodePT) : tokenValueT
        result identTable (nodes (tree).name)
    end literalString

    procedure setLiteralValue (var tree : nodePT, newName : tokenValueT)
        var newToken : tokenT
        ident.install (newName, newToken)
        nodes (tree).name := newToken
    end setLiteralValue


    body procedure applyRule1
        %(ruleName : tokenT,
        % var scope : nodePT,
        % localVars : localsListT,
        % var success : boolean)

	% New Protocol : an external rule must NEVER change the contents of
	%	a node it is passed, otherwise maximal node sharing is defeated.
	%	Instead, a new node must be allocated in that case.
	%	For example, 'newId' must replace 'scope' with a new node
	%	pointer for the result, rather than change the existing node.

	% Set up so that parameter(i) accesses the i'th parameter to the rule
        bind parameter to localVars.local

        const NAME := identTable (ruleName)

        if false then
            % kludge to allow inclusions cleanly

            % TXL predefined external rules
            include "predefined_externals.i"

            % User defined external rules
            include "user_externals.i"

        else
	    error ("In TXL specification, external rule " + identTable (ruleName) +
                " is not implemented.", FATAL)
        end if

    end applyRule1

end externalRules
%child "transform.ch"
% TXL v6.0 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

%parent "txl.t"

stub module transformer
    import var cells, var nodes, var trees, rules, var ident, var identTable, 
	verbose_p, apply_print_p, rule_print_p, tuning_p, printLeaves, printParse, 
	failRule, notRule, var externalRules, error
%	#if DEBUGGER then
	    , debug_p, ruleCount, txlSourceFileName, letterP
	%#end if

    export applyMainRule

    procedure applyMainRule (originalObjectParseTreeNP : nodePT,
        var transformedObjectParseTreeNP : nodePT)

end transformer


body module transformer

    % Kinds of debugger entries
    type * DBkind : 
	enum (startup, shutdown, ruleEntry, ruleExit, matchEntry, matchExit, 
	    deconstructExit, constructEntry, constructExit, conditionExit)

%    #if DEBUGGER then

	% The TXL interactive debugger 
	%child "debug.ch"
% TXL v6.0 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% TXL 5.1 Interactive Debugger
% J.R. Cordy, GMD Karlsruhe, 10.01.91

%parent "transform.ch"

stub module debugger
    import identTable, ident, rules, ruleCount, txlSourceFileName,
	letterP, printLeaves, printParse
    export isbreakpoint, breakpoint

    function isbreakpoint (ruleName : tokenT) : boolean
    procedure breakpoint (kind : DBkind, ruleName : tokenT, partRef : 0 .. maxLocalVars,
	scope : nodePT, localVars : localsListT, success : boolean)
end debugger

body module debugger

    % Global tracing controls
    var nsteps := 0
    var matchfinding := false

    % Rules we are breakpointing at
    const maxbreakpoints := 10
    var breakpoints : array 1 .. maxbreakpoints of tokenT
    var nbreakpoints := 0
    var tempbreakpoint := 0

    procedure setbreakpoint (ruleName : tokenT)
	for bp : 1 .. nbreakpoints
	    if breakpoints (bp) = ruleName then
		put : 0, "  Breakpoint already set at rule ", identTable (ruleName)
		return
	    end if
	end for
	if nbreakpoints >= maxbreakpoints then
	    put : 0, "  ? Too many breakpoints"
	    return
	end if
	nbreakpoints += 1
	breakpoints (nbreakpoints) := ruleName
	put : 0, "  Breakpoint set at rule ", identTable (ruleName)
    end setbreakpoint

    procedure clearbreakpoint (ruleName : tokenT)
	var bp := 1
	loop
	    exit when bp > nbreakpoints or breakpoints (bp) = ruleName
	    bp += 1
	end loop
	if bp > nbreakpoints then
	    put : 0, "  ? Rule not being breakpointed"
	    return
	end if
	nbreakpoints -= 1
	for b : bp .. nbreakpoints
	    breakpoints (b) := breakpoints (b + 1)
	end for
	put : 0, "  Breakpoint cleared at rule ", identTable (ruleName)
    end clearbreakpoint

    function isrealbreakpoint (ruleName : tokenT) : boolean
	for bp : 1 .. nbreakpoints
	    if breakpoints (bp) = ruleName then
		result true
	    end if
	end for
	result false
    end isrealbreakpoint

    body function isbreakpoint % (ruleName : tokenT) : boolean
	if nsteps > 0 or matchfinding then
	    result true
	else
	    result isrealbreakpoint (ruleName)
	end if
    end isbreakpoint

    procedure findruleordefine (sourceFileName: string, sourceDirectory : string, rdId : string,
	    var rdfilename : string, var rdline : int)

	% This is tricky, since we must find the LAST definition!
	% We do that by searching from the beginning of the spec to
	% the end, setting the line and filename whenever we hit a definition.

	var sourceFile := 0
	open : sourceFile, sourceFileName, get

	if sourceFile = 0 then
	   put : 0, "  ? Unable to open ", sourceFileName
	   return
	end if

	var sourceLine := 0
	loop
	    exit when eof (sourceFile)
	    var line : string
	    get : sourceFile, line : *
	    sourceLine += 1

	    if index (line, "rule " + rdId) not= 0 
		    or index (line, "function " + rdId) not= 0 
		    or index (line, "define " + rdId) not= 0 then
		const restOfLineIndex := index (line, rdId) + length (rdId)
		const restOfLine := line (restOfLineIndex .. *)
		const foundit := restOfLine = "" or restOfLine (1) = " "
		if foundit then
		    rdfilename := sourceFileName
		    rdline := sourceLine
		end if

	    elsif index (line, "include \"") not= 0 then
		var includeFileName := line
		includeFileName := 
		    includeFileName (index (includeFileName, "\"") + 1 .. *)
		includeFileName := 
		    includeFileName (1 .. index (includeFileName, "\"") - 1)
		includeFileName := sourceDirectory + includeFileName

		var includeDirectory := ""
		if index (sourceFileName, "/") not= 0 then
		    includeDirectory := includeFileName
		    loop
			exit when includeDirectory (*) = "/"
			includeDirectory := includeDirectory (1 .. *-1)
		    end loop
		end if

		findruleordefine (includeFileName, includeDirectory, rdId, 
		    rdfilename, rdline)
	    end if
	end loop

	close : sourceFile
    end findruleordefine

    % Find source of rule or define
    procedure showruleordefine (rdId : string)
	var sourceFileName := txlSourceFileName
	if index (sourceFileName, ".CTxl") not= 0 then
	    sourceFileName := sourceFileName (1..index (sourceFileName, ".CTxl")) + "Txl"
	end if

	var sourceDirectory := ""
	if index (sourceFileName, "/") not= 0 then
	    sourceDirectory := sourceFileName
	    loop
		exit when sourceDirectory (*) = "/"
		sourceDirectory := sourceDirectory (1 .. *-1)
	    end loop
	end if

	% find the definition of the rule or define
	var rdfilename := ""
	var rdline := 0

	findruleordefine (sourceFileName, sourceDirectory, rdId, rdfilename, rdline)

	% OK, now rdfile and rdline must be the definition
	if rdline = 0 then
	    put : 0, "  ? Couldn't find rule or define of that name"

	else
	    var rdfile : int
	    open : rdfile, rdfilename, get

	    var line : string
	    for ln : 1 .. rdline
		get : rdfile, line : *
	    end for

	    loop
		put : 0, line
		exit when eof (rdfile) 
		    or index (line, "end define") not= 0 
		    or index (line, "end rule") not= 0
		    or index (line, "end function") not= 0
		    or index (line, "external rule") not= 0
		get : rdfile, line : *
	    end loop

	    close : rdfile
	end if
    end showruleordefine


    procedure dbhelp
	put : 0, ""
	put : 0, "                TXL Debugger Commands"
	put : 0, ""
	put : 0, "  rules                 list names of all rules "
	put : 0, "  rule                  list name of current rule"
	put : 0, "  set/clear [RuleName]  set/clear breakpoint at 'RuleName' (default current)"
	put : 0, "  showbps               list names of all rule breakpoints"
	put : 0, "  scope                 print current scope of application"
	put : 0, "  match                 print current pattern match"
	put : 0, "  result                print result of current replacement or rule"
	put : 0, "  vars                  list names of all current visible TXL variables"
	put : 0, "  VarName or 'VarName   print current binding of TXL variable 'VarName'"
	put : 0, "  tree VarName          print tree of current binding of variable 'VarName'"
	put : 0, "  where                 print current rule name and execution state"
	put : 0, "  show [RDname]         print source of rule/define 'RDname' (default current)"
	put : 0, "  go                    continue execution until next breakpoint"
	put : 0, "  /[RuleName]           set brkpt. at 'RuleName' (default current) and continue"
	put : 0, "  //                    continue execution until next pattern match"
	put : 0, "  step [N] or RETURN    step trace execution for N (default 1) steps"
	put : 0, "  help                  print out this help summary"
	put : 0, "  quit                  exit TXL"
	put : 0, ""
    end dbhelp


    body procedure breakpoint % (kind : DBkind, ruleName : tokenT, scope : nodePT,
	    % localVars : localsListT, success : boolean)

	if kind = DBkind.startup or kind = DBkind.shutdown then
	    % initializing or exiting

	elsif isrealbreakpoint (ruleName) then
	    % we got here on a breakpointed rule
	    put : 0, "  >> Breakpoint"
	    nsteps := 0
	    matchfinding := false

	elsif matchfinding then
	    % we're searching for a rule match
	    if kind not= DBkind.matchEntry and kind not= DBkind.shutdown then
		return
	    end if
	else
	    % we must be trace stepping
	    assert nsteps > 0
	end if

	case kind of
	    label DBkind.startup :
		dbhelp

	    label DBkind.shutdown :
		put : 0, "  Exiting mainRule"

	    label DBkind.ruleEntry :
		put : 0, "  Applying rule ", identTable (ruleName)

	    label DBkind.ruleExit :
		put : 0, "  Exiting rule ", identTable (ruleName) ..
		if success then
		    put : 0, " (succeeded)"
		else
		    put : 0, " (failed)"
		end if

	    label DBkind.matchEntry :
		put : 0, "  Matched main pattern of rule ", identTable (ruleName)

	    label DBkind.matchExit :
		put : 0, "  Done replacement of pattern match of rule ", identTable (ruleName) ..
		if success then
		    put : 0, " (succeeded)"
		else
		    put : 0, " (failed)"
		end if

	    label DBkind.constructEntry:
		put : 0, "  Entering construct of ", 
		    identTable (localVars.local (partRef).name), ", in rule ", 
		    identTable (ruleName)

	    label DBkind.constructExit:
		put : 0, "  Exiting construct of ", 
		    identTable (localVars.local (partRef).name), ", in rule ", 
		    identTable (ruleName)

	    label DBkind.deconstructExit:
		put : 0, "  Exiting deconstruct of ", 
		    identTable (localVars.local (partRef).name), ", in rule ", 
		    identTable (ruleName) ..
		if success then
		    put : 0, " (succeeded)"
		else
		    put : 0, " (failed)"
		end if

	    label DBkind.conditionExit:
		put : 0, "  Exiting where condition on ", 
		    identTable (localVars.local (partRef).name), ", in rule ", 
		    identTable (ruleName) ..
		if success then
		    put : 0, " (succeeded)"
		else
		    put : 0, " (failed)"
		end if
	end case

	if nsteps > 0 then
	    nsteps -= 1
	    if nsteps > 0 then
		return
	    end if
	end if

	nsteps := 0
	matchfinding := false

	% Debugger command processor
	loop
	    put : 0, "TXLDB >> " ..
	    var command : string

	    if eof then 
		command := "quit"
	    else
		get command : *
	    end if

	    if command = "rules" then
		var outlength := 0
		for r : 1..ruleCount
		    if outlength + length (identTable (rules (r).name)) + 2 > 78 then
			put : 0, ""
			outlength := 0
		    end if
		    put : 0, "  ", identTable (rules (r).name) ..
		    outlength += length (identTable (rules (r).name)) + 2
		end for
		put : 0, ""

	    elsif command = "rule" then
		put : 0, "  ", identTable (ruleName)

	    elsif command = "step" or index (command, "step ") = 1 or command = "" then
		% trace for one or more steps
		if index (command, " ") not= 0 then
		    command := command (6..*)
		    nsteps := 0
		    loop
			exit when command = "" or command (1) < "0" or command (1) > "9"
			nsteps := nsteps * 10 + ord (command (1)) - ord ("0")
			command := command (2..*)
		    end loop
		    if nsteps = 0 then 
			put : 0, "  ? Bad step count"
		    else
			exit
		    end if
		else
		    nsteps := 1
		    exit
		end if

	    elsif command = "run" or command = "go" then
		exit

	    elsif command = "//" then
		matchfinding := true
		exit

	    elsif index (command, "/") = 1 then
		var ruleId : string
		if length (command) > 1 then
		    ruleId := command (2 .. *)
		else
		    ruleId := identTable (ruleName)
		end if
		const setRuleName := ident.lookup (ruleId)
		var found := false
		for r : 1..ruleCount
		    if rules (r).name = setRuleName then
			found := true
			setbreakpoint (setRuleName)
			exit
		    elsif r = ruleCount then
			put : 0, "  ? No such rule"
			exit
		    end if
		end for

		exit when found 

	    elsif command = "set" or index (command, "set ") = 1 then
		var ruleId : string
		if index (command, " ") not= 0 then
		    ruleId := command (5 .. *)
		else
		    ruleId := identTable (ruleName)
		end if
		const setRuleName := ident.lookup (ruleId)
		for r : 1..ruleCount
		    if rules (r).name = setRuleName then
			setbreakpoint (setRuleName)
			exit
		    elsif r = ruleCount then
			put : 0, "  ? No such rule"
			exit
		    end if
		end for

	    elsif command = "clear" or index (command, "clear ") = 1 then
		var ruleId : string
		if index (command, " ") not= 0 then
		    ruleId := command (7 .. *)
		else
		    ruleId := identTable (ruleName)
		end if
		const clearRuleName := ident.lookup (ruleId)
		for r : 1..ruleCount
		    if rules (r).name = clearRuleName then
			clearbreakpoint (clearRuleName)
			exit
		    elsif r = ruleCount then
			put : 0, "  ? No such rule"
			exit
		    end if
		end for

	    elsif command = "showbps" then
		var outlength := 0
		for bp : 1 .. nbreakpoints
		    if outlength + length (identTable (breakpoints (bp))) + 2 > 78 then
			put : 0, ""
			outlength := 0
		    end if
		    put : 0, "  ", identTable (breakpoints (bp)) ..
		    outlength += length (identTable (breakpoints (bp))) + 2 
		end for
		put : 0, ""

	    elsif command = "show" or index (command, "show ") = 1 then
		var rdId : string
		if index (command, " ") not= 0 then
		    rdId := command (6 .. *)
		else
		    rdId := identTable (ruleName)
		end if
		showruleordefine (rdId)

	    elsif command = "scope" or command = "match" or command = "result" 
		    or command = "tree scope" or command = "tree match" or 
		    command = "tree result" then
		const treeWanted := index (command, "tree") = 1

		if treeWanted then
		    command := command (index (command, " ") + 1 .. *)
		end if

		if (kind = DBkind.ruleEntry or kind = DBkind.startup) 
			    and command = "scope" 
			or kind = DBkind.matchEntry 
			    and command = "match" 
			or (kind = DBkind.matchExit or kind = DBkind.ruleExit 
				or kind = DBkind.constructExit 
				or kind = DBkind.shutdown) 
			    and command = "result" then
		    if treeWanted then
			printParse (scope, 0, true)
		    else
			printLeaves (scope, true)
		    end if
		    put : 0, ""
		else
		    put : 0, "  ? No ", command, " in this context"
		end if

	    elsif command = "vars" then
		for localIndex : 1 .. localVars.nlocals
		    put : 0, "  ", identTable (localVars.local (localIndex).name),
			" [", identTable (localVars.local (localIndex).typename), "]" ..
		end for
		put : 0, ""

	    elsif command = "state" or command = "where" then
		case kind of
		    label DBkind.startup :
			put : 0, "  Applying mainRule"
		    label DBkind.shutdown :
			put : 0, "  Exiting mainRule"
		    label DBkind.ruleEntry :
			put : 0, "  Applying rule ", identTable (ruleName)
		    label DBkind.ruleExit :
			put : 0, "  Exiting rule ", identTable (ruleName) ..
			if success then
			    put : 0, " (succeeded)"
			else
			    put : 0, " (failed)"
			end if
		    label DBkind.matchEntry :
			put : 0, "  Matched pattern of rule ", identTable (ruleName)
		    label DBkind.matchExit :
			put : 0, "  Done replacement of pattern match of rule ", identTable (ruleName) ..
			if success then
			    put : 0, " (succeeded)"
			else
			    put : 0, " (failed)"
			end if
		    label DBkind.constructEntry:
			put : 0, "  Entering construct of ", 
			    identTable (localVars.local (partRef).name), ", in rule ", 
			    identTable (ruleName)
		    label DBkind.constructExit:
			put : 0, "  Exiting construct of ", 
			    identTable (localVars.local (partRef).name), ", in rule ", 
			    identTable (ruleName)
		    label DBkind.deconstructExit:
			put : 0, "  Exiting deconstruct of ", 
			    identTable (localVars.local (partRef).name), ", in rule ", 
			    identTable (ruleName) ..
			if success then
			    put : 0, " (succeeded)"
			else
			    put : 0, " (failed)"
			end if
		    label DBkind.conditionExit:
			put : 0, "  Exiting where condition on ", 
			    identTable (localVars.local (partRef).name), ", in rule ", 
			    identTable (ruleName) ..
			if success then
			    put : 0, " (succeeded)"
			else
			    put : 0, " (failed)"
			end if
		end case

	    elsif command = "help" or command = "?" then
		dbhelp

	    elsif command = "exit" or command = "quit" or command = "bye" then
		put : 0, "  Exiting TXL"
		quit : 0

	    elsif length (command) > 0 then
		const treeWanted := index (command, "tree ") = 1
		if treeWanted then
		    command := command (index (command, " ") + 1 .. *)
		end if

		if command (1) = "'" then
		    command := command (2..*)
		end if

		const c : char := command (1)

		if command = "" or not letterP (c) then
		    put : 0, "  ? bad command ('help' for list of commands)"
		else
		    var found := false
		    for localIndex : 1 .. localVars.nlocals
			if identTable (localVars.local (localIndex).name) = command then
			    if localVars.local (localIndex).valueNP = nilNode then
				put : 0, "  ? unbound"
			    else
				if treeWanted then
				    printParse (localVars.local (localIndex).valueNP, 
					0, true)
				else
				    printLeaves (localVars.local (localIndex).valueNP, 
					true)
				end if
				put : 0, ""
			    end if
			    found := true
			    exit
			end if
		    end for
		    if not found then
			put : 0, "  ? No such variable in the context (or bad command)"
		    end if
		end if

	    else
		% normally can't get here, but what the hey ...
		put : 0, "  ? bad command ('help' for list of commands)"
	    end if
	end loop

    end breakpoint

end debugger

%    #else
%	% dummy debugger
%	const debug_p := false
%
%	module debugger
%	    import error
%	    export isbreakpoint, breakpoint
%
%	    function isbreakpoint (ruleName : tokenT) : boolean
%		error ("Fatal TXL internal error in dummy debugger", FATAL)
%	    end isbreakpoint
%		
%	    procedure breakpoint (kind : DBkind, ruleName : tokenT, 
%		    partRef : 0 .. maxLocalVars, scope : nodePT,
%		    localVars : localsListT, success : boolean)
%		error ("Fatal TXL internal error in dummy debugger", FATAL)
%	    end breakpoint
%	end debugger
%    #end if

    % Name of rule currently being applied (for error messages and such)
    var applyingRuleName : tokenT := failRule  % has to be something!

    % Statistics on tree sharing
    var copies, noncopies := 0


    procedure matchTreeToPattern (patternNP : nodePT, treeNP : nodePT,
            var localVars : localsListT, var yes : boolean)

	bind register patternNode to nodes (patternNP),
	     register treeNode to nodes (treeNP)

        case patternNode.kind of
	    label kindT.empty :
		yes := treeNode.kind = kindT.empty

            label kindT.order :
                if treeNode.kind = kindT.order 
			and patternNode.name = treeNode.name then
                    var patKidsCP := patternNode.kidsCP
                    var treeKidsCP := treeNode.kidsCP

		    assert patKidsCP not= nilCell and treeKidsCP not= nilCell
                    loop
                        matchTreeToPattern (cells (patKidsCP).firstNP,
                            cells (treeKidsCP).firstNP, localVars, yes)

                        if not yes then
			    return
			end if

			patKidsCP := cells (patKidsCP).restCP

                        exit when patKidsCP = nilCell 

			treeKidsCP := cells (treeKidsCP).restCP
			assert treeKidsCP not= nilCell
                    end loop

		    assert cells (treeKidsCP).restCP = nilCell
		    yes := true
                else
                    yes := false
                end if

            label kindT.choose :
                if treeNode.kind = kindT.choose 
			and patternNode.name = treeNode.name then
		    assert treeNode.kidsCP not= nilCell 

		    matchTreeToPattern (cells (patternNode.kidsCP).firstNP,
			cells (treeNode.kidsCP).firstNP, localVars, yes)
                else
                    yes := false
                end if

            label kindT.literal, kindT.stringlit, kindT.charlit, kindT.token, kindT.key,
		    kindT.id, kindT.upperlowerid, kindT.upperid, 
		    kindT.lowerupperid, kindT.lowerid,
		    kindT.number, kindT.floatnumber, kindT.decimalnumber,
		    kindT.integernumber :
                yes := patternNode.name = treeNode.name and 
			patternNode.kind = treeNode.kind

            label kindT.firstTime :
		% the count field tells us the locals index!
                if trees.nodeIsTypeP (treeNP, localVars.local (patternNode.count).typename) then
                    % bind the local variable to the tree
                    localVars.local (patternNode.count).valueNP := treeNP
                    yes := true
                else
                    yes := false
                end if

            label kindT.subsequentUse :
		% the count field tells us the locals index!
                matchTreeToPattern (localVars.local (patternNode.count).valueNP, 
		    treeNP, localVars, yes)

            label kindT.expression, kindT.ruleCall, kindT.undefined :
                error ("Fatal TXL error in matchTreeToPattern", FATAL)
        end case
    end matchTreeToPattern


    forward procedure applyRuleUntilFailureTraversal (rule : ruleT,
	var localVars : localsListT, var treeNP : nodePT, var success : boolean,
	var stopSearching : boolean)
    import var nodes, var cells, debug_p, 
        matchTreeToPattern, forward makeReplacement, forward processParts, var debugger

    forward procedure applyRuleUntilFailureTraversalSkipping (rule : ruleT,
	var localVars : localsListT, var treeNP : nodePT, var success : boolean, 
	var stopSearching : boolean, skipName : tokenT)
    import var nodes, var cells, debug_p, 
	matchTreeToPattern, forward makeReplacement, forward processParts, var debugger

    forward procedure applyRuleUntilFailure (rule : ruleT, var localVars : localsListT,
	originalNP : nodePT, var resultNP : nodePT, var success : boolean)
    import debug_p, applyRuleUntilFailureTraversal, applyRuleUntilFailureTraversalSkipping, 
	forward processParts, var debugger

    forward procedure applyRuleAtRootOnly (rule : ruleT, var localVars : localsListT,
	originalNP : nodePT, var resultNP : nodePT, var success : boolean)
    import debug_p, matchTreeToPattern, forward makeReplacement, 
	forward processParts, var debugger

    forward procedure applyExternalRule (rule : ruleT, var localVars : localsListT,
        originalNP : nodePT, var resultNP : nodePT, var success : boolean)
    import var externalRules, debug_p, var debugger

    forward procedure applyRule (rule : ruleT, var localVars : localsListT,
	originalNP : nodePT, var resultNP : nodePT, var success : boolean)
    import rules, identTable, var applyingRuleName,
        applyExternalRule, applyRuleAtRootOnly, applyRuleUntilFailure,
	rule_print_p


    procedure applyRules (var ruleCallsCP : cellPT, localVars : localsListT,
        var resolvedTreeNP : nodePT, var success : boolean)

	const thisRuleName := applyingRuleName

        success := false

	assert ruleCallsCP not= nilCell

        loop
            const ruleCallNP := cells (ruleCallsCP).firstNP

            assert nodes (ruleCallNP).kind = kindT.ruleCall

	    % rule index encoded in count field of call!
	    const ruleIndex := nodes (ruleCallNP).count

	    if ruleIndex <= numPredefinedRules then

		if nodes (ruleCallNP).name  = failRule then
		    % fail rule - force a failure
		    success := false

		else
		    assert nodes (ruleCallNP).name  = notRule 
		    % not rule - invert success of the rule set
		    success := not success
		end if

            else

                % a user specified rule
		var ruleLocalVars := rules (ruleIndex).localVars

		% bind values to the formal names
		var register litAndVarActualsLeftCP := nodes (ruleCallNP).kidsCP
		var eachIndex := 0

		for arg : 1 .. ruleLocalVars.nformals
		    var register litOrVarActualNP := cells (litAndVarActualsLeftCP).firstNP

                    if nodes (litOrVarActualNP).kind = kindT.subsequentUse then
                        % the count field tells us the locals index!
                        ruleLocalVars.local (arg).valueNP :=
                            localVars.local (nodes (litOrVarActualNP).count).valueNP
                        % and the kidsCP tells us if it is an 'each'ed parameter
                        if nodes (litOrVarActualNP).kidsCP not= nilCell then
                            if eachIndex = 0 then
                                eachIndex := arg
                            end if
                        end if
                    else
                        ruleLocalVars.local (arg).valueNP := litOrVarActualNP
                    end if

                    litAndVarActualsLeftCP := cells (litAndVarActualsLeftCP).restCP
		end for

		bind rule to rules (ruleIndex)

		if eachIndex = 0 then
		    % simple arguments
		    var subruleSuccess : boolean
		    var resultNP : nodePT

		    applyRule (rule, ruleLocalVars, resolvedTreeNP, resultNP, subruleSuccess)

		    success := success or subruleSuccess
		    resolvedTreeNP := resultNP

		else
		    % each specified; arguments each'ed must be lists or repeats
		    % if only one arg, apply rule using each element of the list or repeat;
		    % if two args, apply to corresponding pairs 
		    var each1NP := ruleLocalVars.local (eachIndex).valueNP
		    var each2NP := nilNode

		    if eachIndex < ruleLocalVars.nformals then
			each2NP := ruleLocalVars.local (eachIndex + 1).valueNP
		    end if

		    assert trees.isListOrRepeat (each1NP)
			and each2NP not= nilNode => trees.isListOrRepeat (each2NP)

		    const eachlength := trees.lengthListOrRepeat (each1NP)

		    if each2NP not= nilNode 
			    and eachlength not= trees.lengthListOrRepeat (each2NP) then
			error ("In TXL specification, 'each' argument lengths differ for rule\n" +
			    "  " + identTable (nodes (ruleCallNP).name ) + ", applied in rule " + 
			    identTable (applyingRuleName), FATAL)
		    end if

		    % run through the lists - calls with empty lists do nothing!
		    for i : 1 .. eachlength
			ruleLocalVars.local (eachIndex).valueNP := 
			    trees.listOrRepeatFirstNP (each1NP)

			if each2NP not= nilNode then
			    ruleLocalVars.local (eachIndex + 1).valueNP := 
				trees.listOrRepeatFirstNP (each2NP)
			end if

			var subruleSuccess : boolean
			var resultNP : nodePT

			applyRule (rule, ruleLocalVars, resolvedTreeNP, resultNP, subruleSuccess)

			success := success or subruleSuccess
			resolvedTreeNP := resultNP

			each1NP := trees.listOrRepeatRestNP (each1NP)

			if each2NP not= nilNode then
			    each2NP := trees.listOrRepeatRestNP (each2NP)
			end if
		    end for

		end if  % eachIndex = 0

	    end if  

	    ruleCallsCP := cells (ruleCallsCP).restCP

            exit when ruleCallsCP = nilCell
	end loop

	applyingRuleName := thisRuleName

    end applyRules


    procedure resolveReplacementExpressions (var resolvedReplacementNP : nodePT,
	    var localVars : localsListT, var rulesCalled : boolean, 
	    var rulesSucceeded : boolean, part : partKind, mustCopy : boolean)

        case nodes (resolvedReplacementNP).kind of

            label kindT.order :
                var replacementKidsCP := nodes (resolvedReplacementNP).kidsCP
                assert replacementKidsCP not= nilCell
                loop
                    resolveReplacementExpressions (cells (replacementKidsCP).firstNP,
                        localVars, rulesCalled, rulesSucceeded, part, mustCopy)

                    replacementKidsCP := cells (replacementKidsCP).restCP
                    exit when replacementKidsCP = nilCell
                end loop

            label kindT.choose :
                const replacementKidCP := nodes (resolvedReplacementNP).kidsCP
                assert replacementKidCP not= nilCell

		resolveReplacementExpressions (cells (replacementKidCP).firstNP,
		    localVars, rulesCalled, rulesSucceeded, part, mustCopy)

            label kindT.literal, kindT.stringlit, kindT.charlit, kindT.token, kindT.key,
		    kindT.id, kindT.upperlowerid, kindT.upperid, 
		    kindT.lowerupperid, kindT.lowerid,
		    kindT.number, kindT.floatnumber, kindT.decimalnumber,
		    kindT.integernumber, kindT.empty :
		return

            label kindT.expression :
		% the count field tells us the locals index!
                const localIndex := nodes (resolvedReplacementNP).count

                var ruleCallsCP : cellPT := nodes (resolvedReplacementNP).kidsCP

                if ruleCallsCP not= nilCell then
                    % Apply the subrules to the variable - we must copy 
		    % the variable to be changed unless it has only one reference.
		    % Need not copy ever for condition rules!
		    if mustCopy or 
			    (part not= partKind.cond and 
			     localVars.local (localIndex).refs > 1) then
			% out of luck
			copies += 1
			trees.copyTree (localVars.local (localIndex).valueNP, resolvedReplacementNP)
			if rule_print_p and tuning_p then
			    put:0, "Forced to copy '", 
				identTable (localVars.local (localIndex).name), "'"
			end if
		    else
			noncopies += 1
			resolvedReplacementNP := localVars.local (localIndex).valueNP
		    end if

		    var theseRulesSucceeded := false

                    applyRules (ruleCallsCP, localVars, resolvedReplacementNP, theseRulesSucceeded)

                    rulesCalled := true

		    if theseRulesSucceeded then
			rulesSucceeded := true
		    end if

                else
                    % This variable has no subrules to act on it,
                    % so no chance of changing it.  Just share the
                    % original subtree it's bound to.
		    noncopies += 1
                    resolvedReplacementNP := localVars.local (localIndex).valueNP
                end if

            label kindT.firstTime, kindT.subsequentUse, kindT.ruleCall, kindT.undefined :
		error ("Fatal TXL error in resolveReplacementExpressions", FATAL)
        end case

    end resolveReplacementExpressions


    procedure makeReplacement (replacementNP : nodePT, var subTreeNP : nodePT,
	    var localVars : localsListT, var success : boolean, 
	    part : partKind, mustCopy : boolean)

	var oldTreeNP : nodePT

	if apply_print_p and part = partKind.none then
	    trees.copyTree (subTreeNP, oldTreeNP)
	end if

	assert replacementNP not= nilNode

	% The replacement is one thing we *must* copy every time,
	% since it will become part of the new parse tree.
	var resolvedReplacementNP : nodePT
	trees.copyTree (replacementNP, resolvedReplacementNP)

	var rulesCalled, rulesSucceeded := false

	resolveReplacementExpressions (resolvedReplacementNP, localVars,
	    rulesCalled, rulesSucceeded, part, debug_p or mustCopy)

	if rulesCalled then
	    success := rulesSucceeded 
	else
	    success := true
	end if

	% Link in the resolved replacement for subTree by copying
	% the root node of the replacement subtree into the root
	% node of the original.

	if apply_print_p and success and part = partKind.none then
	    if oldTreeNP not= nilNode then
		printLeaves (oldTreeNP, true)
	    end if
	    put : 0, " ==> " ..
	    printLeaves (resolvedReplacementNP, true)
	    put : 0, " [", identTable (applyingRuleName), "]"
	end if

	% If sharing is done perfectly, it is not necessary to copy this!
	subTreeNP := resolvedReplacementNP

    end makeReplacement


    procedure processParts (ruleName : tokenT, partCount : int,
	    parts : partList, var localVars : localsListT, 
	    var success : boolean, hasPostCondition : boolean)

	success := true

	for i : 1 .. partCount
	    bind part to parts (i)

	    case part.kind of
		label partKind.construct :
%		    #if DEBUGGER then
		    if debug_p and debugger.isbreakpoint (ruleName) then
			debugger.breakpoint (DBkind.constructEntry, 
			    ruleName, part.nameRef, nilNode, localVars, false)
		    end if
%		    #end if

		    var dummySuccess : boolean
		    var resultTree : nodePT := nilNode

		    makeReplacement (part.replacementNP, resultTree, localVars,
			dummySuccess, partKind.construct, hasPostCondition)

		    localVars.local (part.nameRef).valueNP := resultTree

%		    #if DEBUGGER then
		    if debug_p and debugger.isbreakpoint (ruleName) then
			debugger.breakpoint (DBkind.constructExit, 
			    ruleName, part.nameRef, resultTree, localVars, dummySuccess)
		    end if
%		    #end if

		label partKind.deconstruct :
		    % if the deconstructed thing has another reference,
		    % then we must copy since we are creating yet another set of
		    % aliases to it!
		    var valueNP : nodePT
		    if localVars.local (part.nameRef).refs > 1 then
			copies += 1
			trees.copyTree (localVars.local (part.nameRef).valueNP, valueNP)
			if rule_print_p and tuning_p then
			    put:0, "Forced to copy for deconstruct '", 
				identTable (localVars.local (part.nameRef).name), "'"
			end if
		    else
			noncopies += 1
		    	valueNP := localVars.local (part.nameRef).valueNP
		    end if

		    matchTreeToPattern (part.patternNP, valueNP, localVars, success)

%		    #if DEBUGGER then
		    if debug_p and debugger.isbreakpoint (ruleName) then
			debugger.breakpoint (DBkind.deconstructExit, 
			    ruleName, part.nameRef, nilNode, localVars, success)
		    end if
%		    #end if

		label partKind.cond :
		    var dummyResultTree : nodePT := nilNode

		    makeReplacement (part.replacementNP, dummyResultTree, localVars,
			success, partKind.cond, false)

%		    #if DEBUGGER then
		    if debug_p and debugger.isbreakpoint (ruleName) then
			debugger.breakpoint (DBkind.conditionExit, 
			    ruleName, part.nameRef, nilNode, localVars, success)
		    end if
%		    #end if

		label :
		    error ("Fatal TXL error in processParts", FATAL)
	    end case

	    exit when not success
	end for
    end processParts


    body procedure applyRuleUntilFailureTraversal 
	% (rule : ruleT,
	% var localVars : localsListT,
	% var treeNP : nodePT,
	% var success : boolean
	% var stopSearching : boolean)

	pre stopSearching = false

        success := false

	const orderOrChoose := nodes (treeNP).count not= 0

	const potentialMatch := rule.targetKind = nodes (treeNP).kind
	    and (orderOrChoose => rule.targetName = nodes (treeNP).name)

	loop

	    % first, we try as many successive matches at the root as we can get
	    loop
		exit when not potentialMatch

%		#if DEBUGGER then
		if debug_p then
		    for l : localVars.nprelocals + 1 .. localVars.nlocals
			localVars.local (l).valueNP := nilNode
		    end for
		end if
%		#end if

		var found : boolean
		matchTreeToPattern (rule.patternNP, treeNP, localVars, found)

		exit when not found

%		#if DEBUGGER then
		if debug_p and debugger.isbreakpoint (rule.name) then
		    debugger.breakpoint (DBkind.matchEntry, 
			rule.name, 0, treeNP, localVars, false)
		end if
%		#end if

		if rule.postPatternCount > 0 then
		    processParts (rule.name, rule.postPatternCount, rule.postPattern, 
			localVars, found, rule.hasPostCondition)
		    exit when not found
		end if

		if rule.replacementNP = nilNode then
		    % a match rule that found one
		    success := true
		    stopSearching := true
		    return
		else
		    var replacementSuccess : boolean

		    makeReplacement (rule.replacementNP, treeNP, localVars, 
			replacementSuccess, partKind.none, false)

%		    #if DEBUGGER then
		    if debug_p and debugger.isbreakpoint (rule.name) then
			debugger.breakpoint (DBkind.matchExit, 
			    rule.name, 0, treeNP, localVars, replacementSuccess)
		    end if
%		    #end if

		    if not replacementSuccess then
			stopSearching := true
			return
		    end if
		end if

		% if we got here, then replacementSuccess => success
		success := true
	    end loop


	    % we try the kids before trying the root again

	    exit when not orderOrChoose 

	    assert nodes (treeNP).kind = kindT.order or nodes (treeNP).kind = kindT.choose

	    var register resultKidsCP := nodes (treeNP).kidsCP
	    assert resultKidsCP not= nilCell

	    var successInSomeKid := false

	    loop
		var kidSuccess : boolean

		applyRuleUntilFailureTraversal (rule, localVars,
		    cells (resultKidsCP).firstNP, kidSuccess, stopSearching)

		if kidSuccess then
		    successInSomeKid := true
		end if

		if stopSearching then
		    % kid matched but failed its replacement SO STOP
		    if successInSomeKid then
			success := true
		    end if
		    return
		end if

		resultKidsCP := cells (resultKidsCP).restCP

		exit when resultKidsCP = nilCell
	    end loop

	    % no kid matched, so no kid succeeded, SO STOP
	    exit when not successInSomeKid

	    % if we are here, then successInSomeKid => success
	    success := true

	    % if the parent can't change, no sense searching the kids again!
	    exit when not potentialMatch
	end loop

    end applyRuleUntilFailureTraversal


    body procedure applyRuleUntilFailureTraversalSkipping 
	% (rule : ruleT,
	% var localVars : localsListT,
	% var treeNP : nodePT,
	% var success : boolean
	% var stopSearching : boolean,
	% skipName : tokenT)

	pre stopSearching = false

	success := false

	const orderOrChoose := nodes (treeNP).count not= 0

	if orderOrChoose and nodes (treeNP).name = skipName then
	    return
	end if

	const potentialMatch := rule.targetKind = nodes (treeNP).kind
	    and (orderOrChoose => rule.targetName = nodes (treeNP).name)

	loop

	    % first, we try as many successive matches at the root as we can get
	    loop
		exit when not potentialMatch

%		#if DEBUGGER then
		if debug_p then
		    for l : localVars.nprelocals + 1 .. localVars.nlocals
			localVars.local (l).valueNP := nilNode
		    end for
		end if
%		#end if

		var found : boolean
		matchTreeToPattern (rule.patternNP, treeNP, localVars, found)

		exit when not found

%		#if DEBUGGER then
		if debug_p and debugger.isbreakpoint (rule.name) then
		    debugger.breakpoint (DBkind.matchEntry, 
			rule.name, 0, treeNP, localVars, false)
		end if
%		#end if

		if rule.postPatternCount > 0 then
		    processParts (rule.name, rule.postPatternCount, rule.postPattern, 
			localVars, found, rule.hasPostCondition)
		    exit when not found
		end if

		if rule.replacementNP = nilNode then
		    % a match rule that found one
		    success := true
		    stopSearching := true
		    return
		else
		    var replacementSuccess : boolean

		    makeReplacement (rule.replacementNP, treeNP, localVars, 
			replacementSuccess, partKind.none, false)

%		    #if DEBUGGER then
		    if debug_p and debugger.isbreakpoint (rule.name) then
			debugger.breakpoint (DBkind.matchExit, 
			    rule.name, 0, treeNP, localVars, replacementSuccess)
		    end if
%		    #end if

		    if not replacementSuccess then
			stopSearching := true
			return
		    end if
		end if

		% if we got here, then replacementSuccess => success
		success := true
	    end loop


	    % we try the kids before trying the root again

	    exit when not orderOrChoose 

	    assert nodes (treeNP).kind = kindT.order or nodes (treeNP).kind = kindT.choose

	    var register resultKidsCP := nodes (treeNP).kidsCP
	    assert resultKidsCP not= nilCell

	    var successInSomeKid := false

	    loop
		var kidSuccess : boolean

		applyRuleUntilFailureTraversalSkipping (rule, localVars,
		    cells (resultKidsCP).firstNP, kidSuccess, stopSearching, skipName)

		if kidSuccess then
		    successInSomeKid := true
		end if

		if stopSearching then
		    % kid matched but failed its replacement SO STOP
		    if successInSomeKid then
			success := true
		    end if
		    return
		end if

		resultKidsCP := cells (resultKidsCP).restCP

		exit when resultKidsCP = nilCell
	    end loop

	    % no kid matched, so no kid succeeded, SO STOP
	    exit when not successInSomeKid

	    % if we are here, then successInSomeKid => success
	    success := true

	    % if the parent can't change, no sense searching the kids again!
	    exit when not potentialMatch
	end loop

    end applyRuleUntilFailureTraversalSkipping


    body procedure applyRuleUntilFailure 
	% (rule : ruleT,
	% var localVars : localsListT,
	% originalNP : nodePT,
	% var resultNP : nodePT, 
	% var success : boolean)

	var stopSearching := false

	resultNP := originalNP

%	#if DEBUGGER then
	if debug_p then
	    for l : localVars.nformals + 1 .. localVars.nlocals
		localVars.local (l).valueNP := nilNode
	    end for
	end if

	if debug_p and debugger.isbreakpoint (rule.name) then
	    debugger.breakpoint (DBkind.ruleEntry, 
		rule.name, 0, resultNP, localVars, false)
	end if
%	#end if

	if rule.prePatternCount > 0 then
	    processParts (rule.name, rule.prePatternCount, rule.prePattern, localVars, 
		success, false)
	else
	    success := true
	end if

	if success then
	    if rule.skipName = NOT_FOUND then
		applyRuleUntilFailureTraversal (rule, localVars, resultNP,
		    success, stopSearching)
	    else
		applyRuleUntilFailureTraversalSkipping (rule, localVars, resultNP,
		    success, stopSearching, rule.skipName)
	    end if
	end if

%	#if DEBUGGER then
	if debug_p and debugger.isbreakpoint (rule.name) then
	    debugger.breakpoint (DBkind.ruleExit, 
		rule.name, 0, resultNP, localVars, success)
	end if
%	#end if
    end applyRuleUntilFailure


    body procedure applyRuleAtRootOnly 
	% (rule : ruleT,
	% var localVars : localsListT,
	% originalNP : nodePT,
	% var resultNP : nodePT, 
	% var success : boolean)

	var found := false

	resultNP := originalNP % not result yet, but working copy

%	#if DEBUGGER then
	if debug_p then
	    for l : localVars.nformals + 1 .. localVars.nlocals
		localVars.local (l).valueNP := nilNode
	    end for
	end if

	if debug_p and debugger.isbreakpoint (rule.name) then
	    debugger.breakpoint (DBkind.ruleEntry, 
		rule.name, 0, resultNP, localVars, false)
	end if
%	#end if

	if rule.prePatternCount > 0 then
	    processParts (rule.name, rule.prePatternCount, rule.prePattern, localVars, 
		success, false)
	else
	    success := true
	end if

	if success then
	    matchTreeToPattern (rule.patternNP, resultNP, localVars, found)

	    if found then
%		#if DEBUGGER then
		if debug_p and debugger.isbreakpoint (rule.name) then
		    debugger.breakpoint (DBkind.matchEntry, 
			rule.name, 0, resultNP, localVars, false)
		end if
%		#end if

		if rule.postPatternCount > 0 then
		    processParts (rule.name, rule.postPatternCount, rule.postPattern, 
			localVars, found, rule.hasPostCondition)
		end if

		if found then
		    if rule.replacementNP = nilNode then
			% a match function
			success := true
		    else
			makeReplacement (rule.replacementNP, resultNP, localVars, 
			    success, partKind.none, false)

%			#if DEBUGGER then
			if debug_p and debugger.isbreakpoint (rule.name) then
			    debugger.breakpoint (DBkind.matchExit, 
				rule.name, 0, resultNP, localVars, success)
			end if
%			#end if
		    end if
		else
		    success := false
		end if
	    else
		success := false
	    end if
	end if

%	#if DEBUGGER then
	if debug_p and debugger.isbreakpoint (rule.name) then
	    debugger.breakpoint (DBkind.ruleExit, 
		rule.name, 0, resultNP, localVars, success)
	end if
%	#end if
    end applyRuleAtRootOnly


    body procedure applyExternalRule 
	% (rule : ruleT,
	% var localVars : localsListT,
	% originalNP : nodePT,
	% var resultNP : nodePT,
	% var success : boolean)

	% external rules guarantee not to change the values in a node,
	% instead replacing the node with a new one if changed.
	% Thus we can continue to do maximal node sharing.
	resultNP := originalNP

%	#if DEBUGGER then
	if debug_p and debugger.isbreakpoint (rule.name) then
	    debugger.breakpoint (DBkind.ruleEntry, 
		rule.name, 0, resultNP, localVars, false)
	end if

	% yes, we must ask again in case it changed!
	if debug_p and debugger.isbreakpoint (rule.name) then
	    debugger.breakpoint (DBkind.matchEntry, 
		rule.name, 0, resultNP, localVars, false)
	end if
%	#end if

	% call external rule
	externalRules.applyRule1 (rule.name, resultNP, localVars, success)

%	#if DEBUGGER then
	if debug_p and debugger.isbreakpoint (rule.name) then
	    debugger.breakpoint (DBkind.matchExit, 
		rule.name, 0, resultNP, localVars, success)
	end if

	% yes, we must ask again in case it changed!
	if debug_p and debugger.isbreakpoint (rule.name) then
	    debugger.breakpoint (DBkind.ruleExit, 
		rule.name, 0, resultNP, localVars, success)
	end if
%	#end if
    end applyExternalRule


    body procedure applyRule 
	    % (rule : ruleT,
	    % localVars : localsListT,
	    % originalNP : nodePT,
	    % var resultNP : nodePT, 
	    % var success : boolean)

	applyingRuleName := rule.name

	if rule_print_p then
	    put:0, "Entering rule ", identTable (rule.name)
	end if

	if rule.isExternalRule then
	    applyExternalRule (rule, localVars, originalNP, resultNP, success)

	elsif rule.isFunctionRule then
	    applyRuleAtRootOnly (rule, localVars, originalNP, resultNP, success)

	else
	    applyRuleUntilFailure (rule, localVars, originalNP, resultNP, success)
	end if

	if rule_print_p then
	    put:0, "Exiting rule ", identTable (rule.name)
	end if
    end applyRule


    body procedure applyMainRule 
	% (originalObjectParseTreeNP : nodePT,
	% var transformedObjectParseTreeNP : nodePT)

	handler (code)
	    if code = outOfCells or code = outOfNodes then
		put : 0, "    while applying rule '", 
		    identTable (applyingRuleName), "'"
		quit
	    end if
	    quit > : code
	end handler

	const mainRule := numPredefinedRules + 1
	assert rules (mainRule).defined 

	var mainLocalVars := rules (mainRule).localVars
	var dontCareAboutSuccess : boolean

%	#if DEBUGGER then
	if debug_p then
	    debugger.breakpoint (DBkind.startup, 
		rules (mainRule).name, 0, originalObjectParseTreeNP, 
		mainLocalVars, false)
	end if
%	#end if

	applyRule (rules (mainRule), mainLocalVars,
	    originalObjectParseTreeNP, transformedObjectParseTreeNP, dontCareAboutSuccess)

%	#if DEBUGGER then
	if debug_p then
	    debugger.breakpoint (DBkind.shutdown, 
		rules (mainRule).name, 0, transformedObjectParseTreeNP, 
		mainLocalVars, false)
	end if
%	#end if

	if verbose_p and copies + noncopies > 0 then
	    put : 0, "Forced to copy ", copies, " local vars (", 
		copies div (copies + noncopies) * 100, "%)"
	end if

    end applyMainRule

end transformer

% Globals used by the load/store facility
var startSpecNodeCount, startSpecCellCount,
    oldNodeCount, oldCellCount := 0
var objectGrammarTreeNP : nodePT

% The load/store facility for compiled TXL specs
%child "loadstore.ch"
% TXL v6.0 (c) 1988-1991, Queen's University at Kingston
% J.R. Cordy, C.D. Halpern, E.M. Promislow & I.H. Carmichael
% January 1991

% TXL 5.1 Compilation Load/Store Facility
% J.R. Cordy, GMD Karlsruhe, 01.12.90

%parent "txl.t"

stub module LoadStore

    import var identTable, var nodes, var nodeCount,
	var cells, var cellCount, var rules, var ruleIndex, var ruleCount,
	var symbolTable, var symbolTableSize, var objectGrammarTreeNP,
	var compoundTokens, var nCompounds, var keywordTokens, var nKeys,
	var commentTokens, var nComments, var startSpecNodeCount, 
	var startSpecCellCount, error

    export Save, Restore

    procedure Save (tofile : string)
    procedure Restore (fromfile : string)

end LoadStore


body module LoadStore

    % Compressed save and restore for compiled TXL specifications.
    %
    % The optimizations used in this module depend implicitly on several things.
    %
    %	(i) The implementation of the 'nodes' and 'cells' used to represent
    %		trees must be in arrays rather than the more natural collections.
    %
    %	(ii) The parser (parse.ch), grammar tree builder (compile_defines.ch)
    %		and rule table builder (compile_rules.ch) must not try to 
    %		'share' any nodes or cells with the bootstrap or parse of the 
    %		TXL spec (i.e., they must explicitly create new nodes
    %		and cells for everything they build).
    %		
    %	(iii) All pre-initialized nodes and cells, such as 'emptyString', are always
    %		allocated first and lie completely within the first 10 elements
    %		of the 'cells' and 'nodes' arrays.
    %		

    var MAGNUM := 0721696969  % pizza in Karlsruhe

%#if not NOCOMPILE then

    procedure CompressCells
	% This procedure compresses out cells used in
	% the bootstrap and object spec analysis stages to compact
	% the used cells to the beginning of the cell array.
	% This maximizes the free space available for the 
	% transformation step when the compiled spec is used.

	% Step 1. Compress Cells
	%
	% cell pointers appear only in two places:
	%
	%	(i) nodes(*).kidsCP
	%	(ii) cells(*).restCP

	% number of cells reserved for use in initialization
	const reservedCells := 10

	if startSpecCellCount <= reservedCells then
	    % no point in compressing it!
	    return
	end if

	% cell compression shift
	const cellShift := reservedCells - startSpecCellCount

	% (i) compress cell pointers in nodes(*).kidsCP
	for n : startSpecNodeCount .. nodeCount
	    case nodes (n).kind of
		label kindT.order, kindT.choose, kindT.ruleCall, kindT.expression :
		    if nodes (n).kidsCP >= startSpecCellCount then
			nodes (n).kidsCP += cellShift
		    end if
		label :
	    end case
	end for

	% (ii) compress cell pointers in cells(*).restCP
	for c : startSpecCellCount .. cellCount
	    if cells (c).restCP >= startSpecCellCount then
		cells (c).restCP += cellShift
	    end if
	end for

	% (iii) shift the actual cells down
	for c : startSpecCellCount .. cellCount
	    cells (c + cellShift) := cells (c)
	end for

	% document what we've done
	startSpecCellCount += cellShift
	cellCount += cellShift
    end CompressCells

    procedure CompressNodes
	% This procedure compresses out nodes used in
	% the bootstrap and object spec analysis stages to compact
	% the used nodes to the beginning of the node array.
	% This maximizes the free space available for the 
	% transformation step when the compiled spec is used.

	% Step 2. Compress Nodes
	%
	% node pointers appear only in four places:
	%
	%	(i) cells(*).firstNP
	%	(ii) rules(*).patternNP, rules(*).replacementNP, 
	%	     rules(*).localVars.local(*).valueNP,
	%	     rules(*).prePattern(*).patternNP,
	%	     rules(*).prePattern(*).replacementNP,
	%	     rules(*).postPattern(*).patternNP,
	%	     rules(*).postPattern(*).replacementNP
	%	(iii) objectGrammarTreeNP
	%	(iv) symbolTable(*)

	% number of nodes reserved for use in initialization
	const reservedNodes := 10

	if startSpecNodeCount <= reservedNodes then
	    % no point in compressing it!
	    return
	end if

	% node compression shift
	const nodeShift := reservedNodes - startSpecNodeCount

	% (i) compress node pointers in cells(*).firstNP
	for c : startSpecCellCount .. cellCount
	    if cells (c).firstNP >= startSpecNodeCount then
		cells (c).firstNP += nodeShift
	    end if
	end for

	% (ii) compress node pointers in rules(*)
	for r : 1 .. ruleCount
	    bind var rule to rules (r)
	    % rules(*).patternNP
	    if rule.patternNP >= startSpecNodeCount then
		rule.patternNP += nodeShift
	    end if
	    % rules(*).replacementNP
	    if rule.replacementNP >= startSpecNodeCount then
		rule.replacementNP += nodeShift
	    end if
	    % rules(*).localVars.local(*).valueNP
	    for v : 1 .. rule.localVars.nlocals
		if rule.localVars.local (v).valueNP >= startSpecNodeCount then
		    rule.localVars.local (v).valueNP += nodeShift
		end if
	    end for
	    % rules(*).prePattern(*).patternNP, rules(*).prePattern(*).replacementNP
	    for p : 1 .. rule.prePatternCount
		if rule.prePattern (p).patternNP >= startSpecNodeCount then
		    rule.prePattern (p).patternNP += nodeShift
		end if
		if rule.prePattern (p).replacementNP >= startSpecNodeCount then
		    rule.prePattern (p).replacementNP += nodeShift
		end if
	    end for
	    % rules(*).postPattern(*).patternNP, rules(*).postPattern(*).replacementNP
	    for p : 1 .. rule.postPatternCount
		if rule.postPattern (p).patternNP >= startSpecNodeCount then
		    rule.postPattern (p).patternNP += nodeShift
		end if
		if rule.postPattern (p).replacementNP >= startSpecNodeCount then
		    rule.postPattern (p).replacementNP += nodeShift
		end if
	    end for
	end for

	% (iii) objectGrammarTreeNP
	if objectGrammarTreeNP >= startSpecNodeCount then
	    objectGrammarTreeNP += nodeShift
	end if

	% (iv) symbolTable(*)
	for s : 1 .. symbolTableSize
	   if symbolTable (s) >= startSpecNodeCount then
	       symbolTable (s) += nodeShift
	   end if
	end for

	% (v) shift the actual nodes down
	for n : startSpecNodeCount .. nodeCount
	    nodes (n + nodeShift) := nodes (n)
	end for

	% document what we've done
	startSpecNodeCount += nodeShift
	nodeCount += nodeShift
    end CompressNodes

    body procedure Save % (tofile : string)
	% Compress the nodes and cells in the spec to maximize available space
	% when loaded
	CompressCells
	CompressNodes
	% Now store the compiled spec
	var tf : int
	open : tf, tofile, write
	% 0. Header
	write : tf, MAGNUM
	% 1. compoundTokens and commentTokens
	write : tf, nCompounds
	write : tf, compoundTokens (1) : nCompounds * size (compoundT)
	write : tf, nComments
	write : tf, commentTokens (1) : nComments * size (compoundT)
	write : tf, MAGNUM
	% 2. keywords
	write : tf, nKeys
	write : tf, keywordTokens (1) : nKeys * size (tokenT)
	write : tf, MAGNUM
	% 3. identTable
	for i : 128 .. identTableSize - 1
	    if identTable (i) not= "" then
		var ii := i
		var len : nat1 := length (identTable (i))
		write : tf, ii, len, identTable (i) : len
	    end if
	end for
	write : tf, MAGNUM
	% 4. nodes
	write : tf, nodeCount, startSpecNodeCount
	write : tf, nodes (startSpecNodeCount) : 
	    (nodeCount - startSpecNodeCount + 1) * size (patternAndParseNodeT)
	write : tf, MAGNUM
	% 5. cells
	write : tf, cellCount, startSpecCellCount
	write : tf, cells (startSpecCellCount) : 
	    (cellCount - startSpecCellCount + 1) * size (consCellT)
	write : tf, objectGrammarTreeNP
	write : tf, MAGNUM
	% 6. rules
	write : tf, ruleCount
	write : tf, rules (1) : ruleCount * size (ruleT)
	write : tf, ruleIndex (1) : ruleCount * size (ruleIndexT)
	write : tf, MAGNUM
	% 7. symbolTable
	write : tf, symbolTableSize
	write : tf, symbolTable (1) : symbolTableSize * size (nodePT)
	write : tf, MAGNUM
	% 8. EOF
	write : tf, MAGNUM
	close : tf
    end Save

%#else
%    body procedure Save % (tofile : string)
%    end Save
%#end if

    body procedure Restore % (fromfile : string)
	var tf : int
	var mn : int
	open : tf, fromfile, read
	% 1. Header
	read : tf, mn
	if mn not= MAGNUM then
	    error ("(Fatal) Compiled file is not a TXL file", FATAL)
	end if
	% 1. compoundTokens and commentTokens
	read : tf, nCompounds
	read : tf, compoundTokens (1) : nCompounds * size (compoundT)
	read : tf, nComments
	read : tf, commentTokens (1) : nComments * size (compoundT)
	read : tf, mn
	if mn not= MAGNUM then
	    error ("(Fatal) Synchronization error 1 on compiled file", FATAL)
	end if
	% 2. keywords
	read : tf, nKeys
	read : tf, keywordTokens (1) : nKeys * size (tokenT)
	read : tf, mn
	if mn not= MAGNUM then
	    error ("(Fatal) Synchronization error 2 on compiled file", FATAL)
	end if
	% 3. identTable
	loop
	    var i : int
	    read : tf, i
	    exit when i = MAGNUM
	    var len : nat1 
	    read : tf, len
	    read : tf, identTable (i) : len
	end loop
	% 4. nodes
	read : tf, nodeCount, startSpecNodeCount
	read : tf, nodes (startSpecNodeCount) : 
	    (nodeCount - startSpecNodeCount + 1) * size (patternAndParseNodeT)
	read : tf, mn
	if mn not= MAGNUM then
	    error ("(Fatal) Synchronization error 4 on compiled file", FATAL)
	end if
	% 5. cells
	read : tf, cellCount, startSpecCellCount
	read : tf, cells (startSpecCellCount) : 
	    (cellCount - startSpecCellCount + 1) * size (consCellT)
	read : tf, objectGrammarTreeNP
	read : tf, mn
	if mn not= MAGNUM then
	    error ("(Fatal) Synchronization error 5 on compiled file", FATAL)
	end if
	% 6. rules
	read : tf, ruleCount
	read : tf, rules (1) : ruleCount * size (ruleT)
	read : tf, ruleIndex (1) : ruleCount * size (ruleIndexT)
	read : tf, mn
	if mn not= MAGNUM then
	    error ("(Fatal) Synchronization error 6 on compiled file", FATAL)
	end if
	% 7. symbolTable
	read : tf, symbolTableSize
	read : tf, symbolTable (1) : symbolTableSize * size (nodePT)
	read : tf, mn
	if mn not= MAGNUM then
	    error ("(Fatal) Synchronization error 7 on compiled file", FATAL)
	end if
	% 8. EOF
	read : tf, mn
	if mn not= MAGNUM then
	    error ("(Fatal) Synchronization error 8 on compiled file", FATAL)
	end if
	close : tf
    end Restore

end LoadStore


% Main TXL Processor

% Get run-time options from the command line 
getOptions 


% Compile phase

if load_p then
    % Already previously compiled - simply load the compiled file
    put : 0, "Loading ", txlCompiledFileName, " ... "
    LoadStore.Restore (txlCompiledFileName)

    if verbose_p then
	    put : 0, "  ... used ", nodeCount, " nodes and ", cellCount, " cells."
    end if

else

%#if not NOCOMPILE then

    % Step 1. Make the TXL specification language grammar tree
    var txlGrammarTreeNP : nodePT

    if verbose_p then
	    put : 0, "Making the TXL bootstrap grammar tree from ", bootFileName
    else
	    put : 0, "Bootstrapping TXL ... "
    end if

    bootstrap.makeGrammarTree (bootFileName, txlGrammarTreeNP)

    if verbose_p then
	    put : 0, "  ... used ", nodeCount, " nodes and ", cellCount, " cells."
    end if

    oldNodeCount := nodeCount
    oldCellCount := cellCount


    % Step 2. Parse the object language TXL specification using the TXL grammar tree
    var txlSourceParseTreeNP : nodePT := nilNode
    var fail : boolean

    if verbose_p then
	    put : 0, "Scanning the TXL specification ", txlSourceFileName
    else
	    put : 0, "Compiling ", txlSourceFileName, " ... "
    end if

    scanner.tokenize (txlSourceFileName, tokenHandle, lastTokenHandle, true)
    % sets tokenHandle to first token

    failTokenHandle := tokenHandle  % keep track of as far as we parsed successfully

    if verbose_p then
	    put : 0, "Parsing the TXL specification"
    end if

    const save_node_print_p := node_print_p
    node_print_p := false

    parser.parse (txlGrammarTreeNP, txlSourceParseTreeNP, fail)

    node_print_p := save_node_print_p

    if boot_parse_p then
	    printParse (txlSourceParseTreeNP, 0, true)
    end if

    if tokenHandle < lastTokenHandle then
	    % some were left unparsed
	    syntaxError (failTokenHandle)
    end if

    if verbose_p then
	    put : 0, "  ... used ", nodeCount-oldNodeCount, " nodes and ", 
		cellCount-oldCellCount, " cells."
    end if

    oldNodeCount := nodeCount
    oldCellCount := cellCount


    % Step 3. Make the object language grammar tree

    % We save the symbol table from the object language grammar, which contains
    % all the definitions of the syntactic parts (defined by the TXL program)
    % of the object language.
    % These are not needed right away: when the object language source is parsed,
    % only the top level pattern is needed.  But later (in phase two)
    % when the rules are being compiled into a rule table, the patterns
    % and replacements are converted from strings of tokens to "parse" trees
    % including variables and expressions as appropriate.

    startSpecNodeCount := nodeCount
    startSpecCellCount := cellCount

    if verbose_p then
	    put : 0, "Making the object language grammar tree"
    end if

    defineCompiler.makeGrammarTree (txlSourceParseTreeNP, objectGrammarTreeNP)

    if verbose_p then
	    put : 0, "  ... used ", nodeCount-oldNodeCount, " nodes and ", 
		cellCount-oldCellCount, " cells."
    end if

    if grammar_print_p then
	put : 0, skip, "----- Grammar Tree -----"
	printGrammar (objectGrammarTreeNP, 0, false)
	put : 0, "----- End Grammar Tree -----", skip
    end if

    oldNodeCount := nodeCount
    oldCellCount := cellCount


    % Step 4. Make the rule table from the rules in the TXL specification
    if verbose_p then
	    put : 0, "Making the rule table from ", txlSourceFileName
    end if

    ruleCompiler.makeRuleTable (txlSourceParseTreeNP)

    if verbose_p then
	    put : 0, "  ... used ", nodeCount-oldNodeCount, " nodes and ", 
		cellCount-oldCellCount, " cells."
    end if

%#else
%    error ("TXL compiler not configured", FATAL)
%#end if

end if


if compile_p then

%#if not NOCOMPILE then
    % Store the compiled result
    put : 0, "Storing ", txlCompiledFileName, " ... "

    LoadStore.Save (txlCompiledFileName)

    if verbose_p then
	put : 0, "  ... a total of ", nodeCount, " nodes and ", cellCount, " cells."
    end if

    put :0, "Done."

%#else
%    error ("TXL compiler not configured", FATAL)
%#end if

else
    % Transform phase

    oldNodeCount := nodeCount
    oldCellCount := cellCount


    % Step 5. Parse the object source using the object language grammar tree
    var objectParseTreeNP : nodePT := nilNode
    var fail : boolean

    if verbose_p then
	    put : 0, "Scanning the object source ", objectSourceFileName
    else
	put : 0, "Parsing ", objectSourceFileName, " ..."
    end if

    scanner.tokenize (objectSourceFileName, tokenHandle, lastTokenHandle, false)

    failTokenHandle := tokenHandle

    if verbose_p then
	    put : 0, "Parsing the object source"
    end if

    loop
	    parser.parse (objectGrammarTreeNP, objectParseTreeNP, fail)
	    exit when (tokenHandle = lastTokenHandle) or fail
    end loop

    if tokenHandle < lastTokenHandle or fail then
	    % some were left unparsed
	    syntaxError (failTokenHandle) 
    end if

    if parse_print_p then
	    printParse (objectParseTreeNP, 0, true)
    end if

    if verbose_p then
	    put : 0, "  ... used ", nodeCount-oldNodeCount, " nodes and ", 
		cellCount-oldCellCount, " cells."
    end if

    oldNodeCount := nodeCount
    oldCellCount := cellCount


    % Step 6. Apply the rules to transform the parsed object source
    var transformedObjectParseTreeNP : nodePT

    if verbose_p then
	    put : 0, "Applying the transformation rules"
    else
	put : 0, "Transforming ..."
    end if

    transformer.applyMainRule (objectParseTreeNP, transformedObjectParseTreeNP)

    if tree_print_p then
	    printParse (transformedObjectParseTreeNP, 0, true)
    end if

    if verbose_p then
	    put : 0, "  ... used ", nodeCount-oldNodeCount, " nodes and ", 
		cellCount-oldCellCount, " cells."
    end if

    oldNodeCount := nodeCount
    oldCellCount := cellCount


    % Step 7. Generate the transformed object source
    if verbose_p then
	    put : 0, "Generating transformed object langauge source"
    end if

    printSource (transformedObjectParseTreeNP)

    if verbose_p then
	    put : 0, "Used a total of ", nodeCount, " nodes and ", cellCount, " cells."
    end if

end if
