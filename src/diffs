#ifndef NEW
		label kindT.generatelist :
#else /* NEW */
		label kindT.list :
#endif /* NEW */

#ifndef NEW
		    % New style generate list node
#else /* NEW */
		    % New style list+ node
#endif /* NEW */
		    % (No need to check for infinite parse loop on lists)
		    % (Empty listed items handled automatically now)
		    % (Parse stack gets updated for choose nodes only!)

#ifdef NEW
		    % Recover wasted space if we fail
		    oldKidCount := tree.kidCount
		    oldTreeCount := tree.treeCount

#endif /* NEW */
		    % The generated item type
		    productionKidsKP := tree.trees (productionTP).kidsKP

#ifndef NEW
		    % We begin with the first choice.
		    % If it fails, then we take the second (empty) choice.
		    % One or the other always succeeds.
#else /* NEW */
		    % We must have an item, otherwise list+ fails.
#endif /* NEW */

		    % Allocate new parse tree and kids
#ifdef NEW
		    % Name and kind of the parsed node must be the same as for any other list!
#endif /* NEW */
		    parseKidsKP := tree.newKids (2)
#ifndef NEW
		    parseTP := tree.newTreeInit (kindT.list, tree.trees (productionTP).name, tree.trees (productionTP).rawname, 2, parseKidsKP)

		    % Recover wasted space if we end up with the empty case
		    oldKidCount := tree.kidCount
		    oldTreeCount := tree.treeCount
#else /* NEW */
		    parseTP := tree.newTreeInit (kindT.list, tree.trees (tree.kids (productionKidsKP + 1)).name, 
			tree.trees (tree.kids (productionKidsKP + 1)).rawname, 2, parseKidsKP)
#endif /* NEW */

		    % Look for a parse of an item
		    var kidTP := tree.kids (parseKidsKP)
		    real_parse (tree.kids (productionKidsKP), kidTP)
		    tree.setKidTree (parseKidsKP, kidTP)
		    
		    if tree.kids (parseKidsKP) not= nilTree then
			% Got one - now if we have a separator, parse a tail, otherwise make an empty tail
			if nextTokenKind not= kindT.comment and nextToken = comma_T then
			    % Look for more
			    accept
			    kidTP := tree.kids (parseKidsKP + 1)
#ifndef NEW
			    real_parse (productionTP, kidTP)
#else /* NEW */
			    real_parse (tree.kids (productionKidsKP + 1), kidTP)
#endif /* NEW */
			    tree.setKidTree (parseKidsKP + 1, kidTP)
			    assert tree.kids (parseKidsKP + 1) not= nilTree
			    % If the more we got was empty, back off the separator
			    if tree.trees (tree.kids (parseKidsKP + 1)).kind = kindT.list
			    	    and tree.trees (tree.kids (tree.trees (tree.kids (parseKidsKP + 1)).kidsKP + 1)).kind = kindT.empty then
				backup
			    end if
			else
			    % Create an empty tail
#ifndef NEW
		    	    parseKidTP := tree.newTreeInit (kindT.list, tree.trees (productionTP).name, tree.trees (productionTP).rawname, 0, nilKid)
			    tree.makeTwoKids (parseKidTP, emptyTP, emptyTP)
#else /* NEW */
		    	    parseKidTP := tree.newTreeInit (kindT.list, tree.trees (tree.kids (productionKidsKP + 1)).name, 
				tree.trees (tree.kids (productionKidsKP + 1)).rawname, 0, nilKid)
			    tree.makeTwoKids (parseKidTP, emptyTP, emptyTP) 
#endif /* NEW */
			    tree.setKidTree (parseKidsKP + 1, parseKidTP)
			end if
		    else
#ifndef NEW
			% We failed to get a parse - but the empty case always succeeds
			#if not NOCOMPILE then
			if patternParse then
			    % allow an [empty] variable binding
			    tree.setKidTree (parseKidsKP, emptyTP)
			    kidTP := tree.kids (parseKidsKP + 1)
			    real_parse (emptyTP, kidTP)
			    tree.setKidTree (parseKidsKP + 1, kidTP)
			    assert tree.kids (parseKidsKP + 1) not= nilTree	% variable or not, we can always parse an [empty}
			else
			#end if
			    tree.setKidTree (parseKidsKP, emptyTP)
			    tree.setKidTree (parseKidsKP + 1, emptyTP)
			#if not NOCOMPILE then
			end if
			#end if
#else /* NEW */
			% We failed to get a parse - no empty case for list+
			parseTP := nilTree
#endif /* NEW */
			if tree.allocationStrategy = simple then
			    tree.setTreeCount (oldTreeCount)
			    tree.setKidCount (oldKidCount)
			end if
		    end if
